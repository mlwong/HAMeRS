Intel(R) Advisor can now assist with vectorization and show optimization
  report messages with your source code.
See "https://software.intel.com/en-us/intel-advisor-xe" for details.


    Report from: Interprocedural optimizations [ipo]

INLINING OPTION VALUES:
  -inline-factor: 100
  -inline-min-size: 30
  -inline-max-size: 230
  -inline-max-total-size: 2000
  -inline-max-per-routine: 10000
  -inline-max-per-compile: 500000


Begin optimization report for: FlowModel::getEquationsForm(const FlowModel *) const

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (FlowModel::getEquationsForm(const FlowModel *) const) /home/akula/HAMeRS_IB/HAMeRS/include/flow/flow_models/FlowModel.hpp(114,9)

===========================================================================

Begin optimization report for: ConvectiveFluxReconstructor::ConvectiveFluxReconstructor(ConvectiveFluxReconstructor *const, const std::string &, const SAMRAI::tbox::Dimension &, const std::shared_ptr<SAMRAI::geom::CartesianGridGeometry> &, const int &, const FLOW_MODEL::TYPE &, const std::shared_ptr<FlowModel> &, const std::shared_ptr<SAMRAI::tbox::Database> &)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (ConvectiveFluxReconstructor::ConvectiveFluxReconstructor(ConvectiveFluxReconstructor *const, const std::string &, const SAMRAI::tbox::Dimension &, const std::shared_ptr<SAMRAI::geom::CartesianGridGeometry> &, const int &, const FLOW_MODEL::TYPE &, const std::shared_ptr<FlowModel> &, const std::shared_ptr<SAMRAI::tbox::Database> &)) /home/akula/HAMeRS_IB/HAMeRS/include/flow/convective_flux_reconstructors/ConvectiveFluxReconstructor.hpp(26,9)

===========================================================================

Begin optimization report for: ConvectiveFluxReconstructor::~ConvectiveFluxReconstructor(ConvectiveFluxReconstructor *const)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (ConvectiveFluxReconstructor::~ConvectiveFluxReconstructor(ConvectiveFluxReconstructor *const)) [5] /home/akula/HAMeRS_IB/HAMeRS/include/flow/convective_flux_reconstructors/ConvectiveFluxReconstructor.hpp(44,17)
  -> INLINE: (44,17) ConvectiveFluxReconstructor::~ConvectiveFluxReconstructor(ConvectiveFluxReconstructor *)
    -> INLINE: (44,49) std::shared_ptr<SAMRAI::tbox::Database>::~shared_ptr(std::shared_ptr<SAMRAI::tbox::Database> *)
       {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
    -> INLINE: (44,49) std::shared_ptr<FlowModel>::~shared_ptr(std::shared_ptr<FlowModel> *)
       {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
    -> INLINE: (44,49) std::shared_ptr<SAMRAI::geom::CartesianGridGeometry>::~shared_ptr(std::shared_ptr<SAMRAI::geom::CartesianGridGeometry> *)
       {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
    -> INLINE: (44,49) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
       {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}


    Report from: Code generation optimizations [cg]

/home/akula/HAMeRS_IB/HAMeRS/include/flow/convective_flux_reconstructors/ConvectiveFluxReconstructor.hpp(44,17):remark #34051: REGISTER ALLOCATION : [_ZN27ConvectiveFluxReconstructorD0Ev] /home/akula/HAMeRS_IB/HAMeRS/include/flow/convective_flux_reconstructors/ConvectiveFluxReconstructor.hpp:44

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    8[ rax rdx rcx rbx rbp rsi rdi r12]
        
    Routine temporaries
        Total         :      64
            Global    :      29
            Local     :      35
        Regenerable   :      14
        Spilled       :       3
        
    Routine stack
        Variables     :       1 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: ConvectiveFluxReconstructor::~ConvectiveFluxReconstructor(ConvectiveFluxReconstructor *const)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (ConvectiveFluxReconstructor::~ConvectiveFluxReconstructor(ConvectiveFluxReconstructor *const)) /home/akula/HAMeRS_IB/HAMeRS/include/flow/convective_flux_reconstructors/ConvectiveFluxReconstructor.hpp(44,17)

===========================================================================

Begin optimization report for: ConvectiveFluxReconstructorCentral::ConvectiveFluxReconstructorCentral(ConvectiveFluxReconstructorCentral *const, const std::string &, const SAMRAI::tbox::Dimension &, const std::shared_ptr<SAMRAI::geom::CartesianGridGeometry> &, const int &, const FLOW_MODEL::TYPE &, const std::shared_ptr<FlowModel> &, const std::shared_ptr<SAMRAI::tbox::Database> &)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (ConvectiveFluxReconstructorCentral::ConvectiveFluxReconstructorCentral(ConvectiveFluxReconstructorCentral *const, const std::string &, const SAMRAI::tbox::Dimension &, const std::shared_ptr<SAMRAI::geom::CartesianGridGeometry> &, const int &, const FLOW_MODEL::TYPE &, const std::shared_ptr<FlowModel> &, const std::shared_ptr<SAMRAI::tbox::Database> &)) [7] /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(11,37)
  -> (11,37) ConvectiveFluxReconstructorCentral::ConvectiveFluxReconstructorCentral(ConvectiveFluxReconstructorCentral *, const std::string &, const SAMRAI::tbox::Dimension &, const std::shared_ptr<SAMRAI::geom::CartesianGridGeometry> &, const int &, const FLOW_MODEL::TYPE &, const std::shared_ptr<FlowModel> &, const std::shared_ptr<SAMRAI::tbox::Database> &)


    Report from: Code generation optimizations [cg]

/home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(11,37):remark #34051: REGISTER ALLOCATION : [_ZN34ConvectiveFluxReconstructorCentralC2ERKSsRKN6SAMRAI4tbox9DimensionERKSt10shared_ptrINS2_4geom21CartesianGridGeometryEERKiRKN10FLOW_MODEL4TYPEERKS7_I9FlowModelERKS7_INS3_8DatabaseEE] /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp:11

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rdx rcx rsi rdi r8-r9]
        
    Routine temporaries
        Total         :      24
            Global    :       0
            Local     :      24
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: ConvectiveFluxReconstructorCentral::ConvectiveFluxReconstructorCentral(ConvectiveFluxReconstructorCentral *, const std::string &, const SAMRAI::tbox::Dimension &, const std::shared_ptr<SAMRAI::geom::CartesianGridGeometry> &, const int &, const FLOW_MODEL::TYPE &, const std::shared_ptr<FlowModel> &, const std::shared_ptr<SAMRAI::tbox::Database> &)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (ConvectiveFluxReconstructorCentral::ConvectiveFluxReconstructorCentral(ConvectiveFluxReconstructorCentral *, const std::string &, const SAMRAI::tbox::Dimension &, const std::shared_ptr<SAMRAI::geom::CartesianGridGeometry> &, const int &, const FLOW_MODEL::TYPE &, const std::shared_ptr<FlowModel> &, const std::shared_ptr<SAMRAI::tbox::Database> &)) [8] /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(27,1)
  -> (11,37) std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>>::~vector(std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>> *)
  -> (11,37) std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>>::vector(std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>> *)
  -> INLINE: (26,13) ConvectiveFluxReconstructor::~ConvectiveFluxReconstructor(ConvectiveFluxReconstructor *const)
    -> /home/akula/HAMeRS_IB/HAMeRS/include/flow/convective_flux_reconstructors/ConvectiveFluxReconstructor.hpp:(44,17) ConvectiveFluxReconstructor::~ConvectiveFluxReconstructor(ConvectiveFluxReconstructor *)
  -> INLINE: (26,13) ConvectiveFluxReconstructor::ConvectiveFluxReconstructor(ConvectiveFluxReconstructor *const, const std::string &, const SAMRAI::tbox::Dimension &, const std::shared_ptr<SAMRAI::geom::CartesianGridGeometry> &, const int &, const FLOW_MODEL::TYPE &, const std::shared_ptr<FlowModel> &, const std::shared_ptr<SAMRAI::tbox::Database> &)
    -> /home/akula/HAMeRS_IB/HAMeRS/include/flow/convective_flux_reconstructors/ConvectiveFluxReconstructor.hpp:(26,9) ConvectiveFluxReconstructor::ConvectiveFluxReconstructor(ConvectiveFluxReconstructor *, const std::string &, const SAMRAI::tbox::Dimension &, const std::shared_ptr<SAMRAI::geom::CartesianGridGeometry> &, const int &, const FLOW_MODEL::TYPE &, const std::shared_ptr<FlowModel> &, const std::shared_ptr<SAMRAI::tbox::Database> &)
  -> INLINE: (28,5) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (28,5) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (28,49) std::__shared_ptr<SAMRAI::tbox::Database, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::tbox::Database, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (29,31) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (29,31) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (29,31) std::allocator<char>::allocator(std::allocator<char> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INDIRECT- (VIRTUAL): (29,40)  EXPR_CONV.SI64.P64(*((SI64*) (__$U98_V$c8d.0.606->__vptr_V$c90 + EXPR_CONV.SI32.I64(66(SI32)) * 8(I64))))
  -> DELETED: (30,5) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (30,5) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (30,49) std::__shared_ptr<SAMRAI::tbox::Database, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::tbox::Database, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (31,31) std::allocator<char>::allocator(std::allocator<char> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (31,31) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (31,31) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INDIRECT- (VIRTUAL): (31,42)  EXPR_CONV.SI64.P64(*((SI64*) (__$U99_V$c8e.0.606->__vptr_V$c90 + EXPR_CONV.SI32.I64(66(SI32)) * 8(I64))))
  -> INLINE: (36,27) SAMRAI::hier::IntVector::operator=(SAMRAI::hier::IntVector *, const SAMRAI::hier::IntVector &)
    -> /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(189,16) std::vector<int, std::allocator<int>>::operator=(std::vector<int, std::allocator<int>> *, const std::vector<int, std::allocator<int>> &)
  -> INLINE: (36,29) SAMRAI::hier::IntVector::getOne(const SAMRAI::tbox::Dimension &)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(1146,27) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
  -> INLINE: (40,27) SAMRAI::hier::IntVector::operator=(SAMRAI::hier::IntVector *, const SAMRAI::hier::IntVector &)
    -> /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(189,16) std::vector<int, std::allocator<int>>::operator=(std::vector<int, std::allocator<int>> *, const std::vector<int, std::allocator<int>> &)
  -> INLINE: (40,29) SAMRAI::hier::IntVector::getOne(const SAMRAI::tbox::Dimension &)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(1146,27) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
  -> INLINE: (40,59) SAMRAI::hier::IntVector::operator*(SAMRAI::hier::IntVector *, const SAMRAI::hier::IntVector *, int) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(571,11) SAMRAI::hier::IntVector::operator*=(SAMRAI::hier::IntVector *, int)
      -> INLINE: (556,44) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
      -> INLINE: (558,18) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (44,27) SAMRAI::hier::IntVector::operator=(SAMRAI::hier::IntVector *, const SAMRAI::hier::IntVector &)
    -> /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(189,16) std::vector<int, std::allocator<int>>::operator=(std::vector<int, std::allocator<int>> *, const std::vector<int, std::allocator<int>> &)
  -> INLINE: (44,29) SAMRAI::hier::IntVector::getOne(const SAMRAI::tbox::Dimension &)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(1146,27) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
  -> INLINE: (44,59) SAMRAI::hier::IntVector::operator*(SAMRAI::hier::IntVector *, const SAMRAI::hier::IntVector *, int) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(571,11) SAMRAI::hier::IntVector::operator*=(SAMRAI::hier::IntVector *, int)
      -> INLINE: (556,44) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
      -> INLINE: (558,18) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (48,27) SAMRAI::hier::IntVector::operator=(SAMRAI::hier::IntVector *, const SAMRAI::hier::IntVector &)
    -> /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(189,16) std::vector<int, std::allocator<int>>::operator=(std::vector<int, std::allocator<int>> *, const std::vector<int, std::allocator<int>> &)
  -> INLINE: (48,29) SAMRAI::hier::IntVector::getOne(const SAMRAI::tbox::Dimension &)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(1146,27) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
  -> INLINE: (48,59) SAMRAI::hier::IntVector::operator*(SAMRAI::hier::IntVector *, const SAMRAI::hier::IntVector *, int) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(571,11) SAMRAI::hier::IntVector::operator*=(SAMRAI::hier::IntVector *, int)
      -> INLINE: (556,44) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
      -> INLINE: (558,18) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (52,27) SAMRAI::hier::IntVector::operator=(SAMRAI::hier::IntVector *, const SAMRAI::hier::IntVector &)
    -> /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(189,16) std::vector<int, std::allocator<int>>::operator=(std::vector<int, std::allocator<int>> *, const std::vector<int, std::allocator<int>> &)
  -> INLINE: (52,29) SAMRAI::hier::IntVector::getOne(const SAMRAI::tbox::Dimension &)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(1146,27) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
  -> INLINE: (52,59) SAMRAI::hier::IntVector::operator*(SAMRAI::hier::IntVector *, const SAMRAI::hier::IntVector *, int) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(571,11) SAMRAI::hier::IntVector::operator*=(SAMRAI::hier::IntVector *, int)
      -> INLINE: (556,44) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
      -> INLINE: (558,18) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (56,27) SAMRAI::hier::IntVector::operator=(SAMRAI::hier::IntVector *, const SAMRAI::hier::IntVector &)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(189,16) std::vector<int, std::allocator<int>>::operator=(std::vector<int, std::allocator<int>> *, const std::vector<int, std::allocator<int>> &)
       {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (56,29) SAMRAI::hier::IntVector::getOne(const SAMRAI::tbox::Dimension &)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(1146,27) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
  -> INLINE: (56,59) SAMRAI::hier::IntVector::operator*(SAMRAI::hier::IntVector *, const SAMRAI::hier::IntVector *, int) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(571,11) SAMRAI::hier::IntVector::operator*=(SAMRAI::hier::IntVector *, int)
      -> INLINE: (556,44) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
      -> INLINE: (558,18) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (60,9) std::allocator<char>::allocator(std::allocator<char> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (60,9) std::basic_ostringstream<char, std::char_traits<char>, std::allocator<char>>::~basic_ostringstream(std::basic_ostringstream<char, std::char_traits<char>, std::allocator<char>> *const)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (60,9) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (60,9) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (60,9) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (60,9) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (60,9) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (60,9) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> (60,9) std::operator<<<std::char_traits<char>>(std::basic_ostream<char, std::char_traits<char>> &, const char *)
  -> INLINE: (60,9) std::basic_ostringstream<char, std::char_traits<char>, std::allocator<char>>::str(std::basic_ostringstream<char, std::char_traits<char>, std::allocator<char>>::__string_type *, const std::basic_ostringstream<char, std::char_traits<char>, std::allocator<char>> *) const
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (60,9) std::basic_ostringstream<char, std::char_traits<char>, std::allocator<char>>::~basic_ostringstream(std::basic_ostringstream<char, std::char_traits<char>, std::allocator<char>> *const)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (60,9) std::basic_ostringstream<char, std::char_traits<char>, std::allocator<char>>::basic_ostringstream(std::basic_ostringstream<char, std::char_traits<char>, std::allocator<char>> *const, std::ios_base::openmode)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (64,16) std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>>::operator=(std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>> *, const std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>> &)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (64,30) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (64,32) FlowModel::getEquationsForm(const FlowModel *) const
  -> INLINE: (68,23) std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>>::operator[](std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>> *, std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>>::size_type)
  -> DELETED: (74,24) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (74,24) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (74,24) std::shared_ptr<SAMRAI::tbox::Timer>::~shared_ptr(std::shared_ptr<SAMRAI::tbox::Timer> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (74,24) std::shared_ptr<SAMRAI::tbox::Timer>::operator=(std::shared_ptr<SAMRAI::tbox::Timer> *, std::shared_ptr<SAMRAI::tbox::Timer> &&)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (75,18) std::allocator<char>::allocator(std::allocator<char> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (75,18) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (75,18) std::allocator<char>::~allocator(std::allocator<char> *)
  -> DELETED: (77,22) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (77,22) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (77,22) std::shared_ptr<SAMRAI::tbox::Timer>::~shared_ptr(std::shared_ptr<SAMRAI::tbox::Timer> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (77,22) std::shared_ptr<SAMRAI::tbox::Timer>::operator=(std::shared_ptr<SAMRAI::tbox::Timer> *, std::shared_ptr<SAMRAI::tbox::Timer> &&)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (78,18) std::allocator<char>::allocator(std::allocator<char> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (78,18) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (78,18) std::allocator<char>::~allocator(std::allocator<char> *)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h(557,7) inlined into /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(56,59)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed FLOW dependence between *(U9f_V.U9f_V.U9f_V.U9f_V.U9f_V+i*4) (558:18) and *(U9f_V.U9f_V.U9f_V.U9f_V.U9f_V+i*4) (558:18)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h(557,7) inlined into /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(56,59)
<Remainder>
LOOP END

LOOP BEGIN at /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h(557,7) inlined into /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(52,59)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed FLOW dependence between *(U9e_V.U9e_V.U9e_V.U9e_V.U9e_V+i*4) (558:18) and *(U9e_V.U9e_V.U9e_V.U9e_V.U9e_V+i*4) (558:18)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h(557,7) inlined into /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(52,59)
<Remainder>
LOOP END

LOOP BEGIN at /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h(557,7) inlined into /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(48,59)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed FLOW dependence between *(U9d_V.U9d_V.U9d_V.U9d_V.U9d_V+i*4) (558:18) and *(U9d_V.U9d_V.U9d_V.U9d_V.U9d_V+i*4) (558:18)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h(557,7) inlined into /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(48,59)
<Remainder>
LOOP END

LOOP BEGIN at /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h(557,7) inlined into /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(44,59)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed FLOW dependence between *(U9c_V.U9c_V.U9c_V.U9c_V.U9c_V+i*4) (558:18) and *(U9c_V.U9c_V.U9c_V.U9c_V.U9c_V+i*4) (558:18)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h(557,7) inlined into /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(44,59)
<Remainder>
LOOP END

LOOP BEGIN at /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h(557,7) inlined into /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(40,59)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed FLOW dependence between *(U9b_V.U9b_V.U9b_V.U9b_V.U9b_V+i*4) (558:18) and *(U9b_V.U9b_V.U9b_V.U9b_V.U9b_V+i*4) (558:18)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h(557,7) inlined into /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(40,59)
<Remainder>
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(66,5)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed FLOW dependence between this->d_has_advective_eqn_form (70:13) and this[ei] (68:9)
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(66,5)
<Remainder>
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_algobase.h(372,6):remark #34026: call to memmove implemented as a call to optimized library version
/usr/include/c++/4.8.5/bits/stl_algobase.h(372,6):remark #34026: call to memmove implemented as a call to optimized library version
/usr/include/c++/4.8.5/bits/stl_algobase.h(372,6):remark #34026: call to memmove implemented as a call to optimized library version
/usr/include/c++/4.8.5/bits/char_traits.h(271,40):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/c++/4.8.5/bits/char_traits.h(271,40):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/c++/4.8.5/bits/stl_algobase.h(372,6):remark #34026: call to memmove implemented as a call to optimized library version
/usr/include/c++/4.8.5/bits/stl_algobase.h(372,6):remark #34026: call to memmove implemented as a call to optimized library version
/usr/include/c++/4.8.5/bits/stl_algobase.h(372,6):remark #34026: call to memmove implemented as a call to optimized library version
/usr/include/c++/4.8.5/bits/shared_ptr_base.h(789,7):remark #34000: call to memset implemented inline with stores with proven (alignment, offset): (32, 8)
/usr/include/c++/4.8.5/bits/shared_ptr_base.h(789,7):remark #34000: call to memset implemented inline with stores with proven (alignment, offset): (32, 8)
/usr/include/c++/4.8.5/bits/stl_algobase.h(372,6):remark #34026: call to memmove implemented as a call to optimized library version
/usr/include/c++/4.8.5/bits/stl_algobase.h(372,6):remark #34026: call to memmove implemented as a call to optimized library version
/home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(27,1):remark #34051: REGISTER ALLOCATION : [_ZN34ConvectiveFluxReconstructorCentralC1ERKSsRKN6SAMRAI4tbox9DimensionERKSt10shared_ptrINS2_4geom21CartesianGridGeometryEERKiRKN10FLOW_MODEL4TYPEERKS7_I9FlowModelERKS7_INS3_8DatabaseEE] /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp:27

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   14[ rax rdx rcx rbx rsi rdi r8-r15]
        
    Routine temporaries
        Total         :     818
            Global    :     191
            Local     :     627
        Regenerable   :     220
        Spilled       :      10
        
    Routine stack
        Variables     :     730 bytes*
            Reads     :      74 [2.05e+01 ~ 6.3%]
            Writes    :      78 [2.94e+01 ~ 9.0%]
        Spills        :      40 bytes*
            Reads     :       7 [1.92e-01 ~ 0.1%]
            Writes    :       7 [1.92e-01 ~ 0.1%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::char_traits<char>::length(const std::char_traits<char>::char_type *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/char_traits.h(259,7):remark #34051: REGISTER ALLOCATION : [_ZNSt11char_traitsIcE6lengthEPKc] /usr/include/c++/4.8.5/bits/char_traits.h:259

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rax rdx rdi]
        
    Routine temporaries
        Total         :      12
            Global    :       7
            Local     :       5
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::vector<int, std::allocator<int>>::operator=(std::vector<int, std::allocator<int>> *, const std::vector<int, std::allocator<int>> &)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_algobase.h(372,6):remark #34026: call to memmove implemented as a call to optimized library version
/usr/include/c++/4.8.5/bits/stl_algobase.h(372,6):remark #34026: call to memmove implemented as a call to optimized library version
/usr/include/c++/4.8.5/bits/stl_algobase.h(372,6):remark #34026: call to memmove implemented as a call to optimized library version
/usr/include/c++/4.8.5/bits/stl_algobase.h(372,6):remark #34026: call to memmove implemented as a call to optimized library version
/usr/include/c++/4.8.5/bits/vector.tcc(162,5):remark #34051: REGISTER ALLOCATION : [_ZNSt6vectorIiSaIiEEaSERKS1_] /usr/include/c++/4.8.5/bits/vector.tcc:162

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   11[ rax rdx rcx rbx rbp rsi rdi r12-r15]
        
    Routine temporaries
        Total         :      56
            Global    :      22
            Local     :      34
        Regenerable   :       1
        Spilled       :       6
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::_Vector_base<int, std::allocator<int>>::_M_deallocate(std::_Vector_base<int, std::allocator<int>> *, std::_Vector_base<int, std::allocator<int>>::pointer, std::size_t)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_vector.h(172,7):remark #34051: REGISTER ALLOCATION : [_ZNSt12_Vector_baseIiSaIiEE13_M_deallocateEPim] /usr/include/c++/4.8.5/bits/stl_vector.h:172

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rdx rsi rdi]
        
    Routine temporaries
        Total         :      11
            Global    :       7
            Local     :       4
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: ConvectiveFluxReconstructor::ConvectiveFluxReconstructor(ConvectiveFluxReconstructor *, const std::string &, const SAMRAI::tbox::Dimension &, const std::shared_ptr<SAMRAI::geom::CartesianGridGeometry> &, const int &, const FLOW_MODEL::TYPE &, const std::shared_ptr<FlowModel> &, const std::shared_ptr<SAMRAI::tbox::Database> &)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (ConvectiveFluxReconstructor::ConvectiveFluxReconstructor(ConvectiveFluxReconstructor *, const std::string &, const SAMRAI::tbox::Dimension &, const std::shared_ptr<SAMRAI::geom::CartesianGridGeometry> &, const int &, const FLOW_MODEL::TYPE &, const std::shared_ptr<FlowModel> &, const std::shared_ptr<SAMRAI::tbox::Database> &)) [21] /home/akula/HAMeRS_IB/HAMeRS/include/flow/convective_flux_reconstructors/ConvectiveFluxReconstructor.hpp(42,9)
  -> INLINE: (34,31) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> (36,33) std::shared_ptr<SAMRAI::geom::CartesianGridGeometry>::~shared_ptr(std::shared_ptr<SAMRAI::geom::CartesianGridGeometry> *)
  -> INLINE: (36,33) std::shared_ptr<SAMRAI::geom::CartesianGridGeometry>::shared_ptr(std::shared_ptr<SAMRAI::geom::CartesianGridGeometry> *, const std::shared_ptr<SAMRAI::geom::CartesianGridGeometry> &)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (37,35) SAMRAI::hier::IntVector::getZero(const SAMRAI::tbox::Dimension &)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(1133,28) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
  -> INLINE: (40,30) std::shared_ptr<FlowModel>::shared_ptr(std::shared_ptr<FlowModel> *, const std::shared_ptr<FlowModel> &)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (41,52) std::shared_ptr<SAMRAI::tbox::Database>::shared_ptr(std::shared_ptr<SAMRAI::tbox::Database> *, const std::shared_ptr<SAMRAI::tbox::Database> &)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}


    Report from: Code generation optimizations [cg]

/home/akula/HAMeRS_IB/HAMeRS/include/flow/convective_flux_reconstructors/ConvectiveFluxReconstructor.hpp(42,9):remark #34051: REGISTER ALLOCATION : [_ZN27ConvectiveFluxReconstructorC1ERKSsRKN6SAMRAI4tbox9DimensionERKSt10shared_ptrINS2_4geom21CartesianGridGeometryEERKiRKN10FLOW_MODEL4TYPEERKS7_I9FlowModelERKS7_INS3_8DatabaseEE] /home/akula/HAMeRS_IB/HAMeRS/include/flow/convective_flux_reconstructors/ConvectiveFluxReconstructor.hpp:42

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   13[ rax rdx rcx rbx rbp rsi rdi r8-r9 r12-r15]
        
    Routine temporaries
        Total         :      71
            Global    :      24
            Local     :      47
        Regenerable   :      10
        Spilled       :       7
        
    Routine stack
        Variables     :       9 bytes*
            Reads     :       1 [0.00e+00 ~ 0.0%]
            Writes    :       2 [0.00e+00 ~ 0.0%]
        Spills        :       8 bytes*
            Reads     :       1 [0.00e+00 ~ 0.0%]
            Writes    :       1 [1.00e+00 ~ 1.2%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::shared_ptr<SAMRAI::geom::CartesianGridGeometry>::~shared_ptr(std::shared_ptr<SAMRAI::geom::CartesianGridGeometry> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/shared_ptr.h(93,11):remark #34051: REGISTER ALLOCATION : [_ZNSt10shared_ptrIN6SAMRAI4geom21CartesianGridGeometryEED1Ev] /usr/include/c++/4.8.5/bits/shared_ptr.h:93

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rcx rdi r12-r13]
        
    Routine temporaries
        Total         :      24
            Global    :      12
            Local     :      12
        Regenerable   :       3
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>>::vector(std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_vector.h(249,17):remark #34051: REGISTER ALLOCATION : [_ZNSt6vectorIN8EQN_FORM4TYPEESaIS1_EEC1Ev] /usr/include/c++/4.8.5/bits/stl_vector.h:249

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdi]
        
    Routine temporaries
        Total         :       9
            Global    :       0
            Local     :       9
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: ConvectiveFluxReconstructor::~ConvectiveFluxReconstructor(ConvectiveFluxReconstructor *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (ConvectiveFluxReconstructor::~ConvectiveFluxReconstructor(ConvectiveFluxReconstructor *)) [25] /home/akula/HAMeRS_IB/HAMeRS/include/flow/convective_flux_reconstructors/ConvectiveFluxReconstructor.hpp(44,48)
  -> INLINE: (44,49) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (44,49) std::shared_ptr<SAMRAI::geom::CartesianGridGeometry>::~shared_ptr(std::shared_ptr<SAMRAI::geom::CartesianGridGeometry> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (44,49) std::shared_ptr<FlowModel>::~shared_ptr(std::shared_ptr<FlowModel> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (44,49) std::shared_ptr<SAMRAI::tbox::Database>::~shared_ptr(std::shared_ptr<SAMRAI::tbox::Database> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}


    Report from: Code generation optimizations [cg]

/home/akula/HAMeRS_IB/HAMeRS/include/flow/convective_flux_reconstructors/ConvectiveFluxReconstructor.hpp(44,48):remark #34051: REGISTER ALLOCATION : [_ZN27ConvectiveFluxReconstructorD1Ev] /home/akula/HAMeRS_IB/HAMeRS/include/flow/convective_flux_reconstructors/ConvectiveFluxReconstructor.hpp:44

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    8[ rax rdx rcx rbx rbp rsi rdi r12]
        
    Routine temporaries
        Total         :      63
            Global    :      29
            Local     :      34
        Regenerable   :      14
        Spilled       :       3
        
    Routine stack
        Variables     :       1 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>>::~vector(std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_vector.h(415,7):remark #34051: REGISTER ALLOCATION : [_ZNSt6vectorIN8EQN_FORM4TYPEESaIS1_EED1Ev] /usr/include/c++/4.8.5/bits/stl_vector.h:415

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    1[ rdi]
        
    Routine temporaries
        Total         :      10
            Global    :       7
            Local     :       3
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::_Vector_base<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>>::~_Vector_base(std::_Vector_base<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_vector.h(160,7):remark #34051: REGISTER ALLOCATION : [_ZNSt12_Vector_baseIN8EQN_FORM4TYPEESaIS1_EED1Ev] /usr/include/c++/4.8.5/bits/stl_vector.h:160

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    1[ rdi]
        
    Routine temporaries
        Total         :      10
            Global    :       7
            Local     :       3
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::_Vector_base<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>>::_M_deallocate(std::_Vector_base<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>> *, std::_Vector_base<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>>::pointer, std::size_t)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_vector.h(172,7):remark #34051: REGISTER ALLOCATION : [_ZNSt12_Vector_baseIN8EQN_FORM4TYPEESaIS1_EE13_M_deallocateEPS1_m] /usr/include/c++/4.8.5/bits/stl_vector.h:172

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rdx rsi rdi]
        
    Routine temporaries
        Total         :      11
            Global    :       7
            Local     :       4
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: ConvectiveFluxReconstructorCentral::~ConvectiveFluxReconstructorCentral(ConvectiveFluxReconstructorCentral *)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (ConvectiveFluxReconstructorCentral::~ConvectiveFluxReconstructorCentral(ConvectiveFluxReconstructorCentral *)) [33] /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(83,1)
  -> INLINE: (84,24) std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic>::reset(std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (85,22) std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic>::reset(std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (86,1) ConvectiveFluxReconstructor::~ConvectiveFluxReconstructor(ConvectiveFluxReconstructor *const)
    -> INLINE: /home/akula/HAMeRS_IB/HAMeRS/include/flow/convective_flux_reconstructors/ConvectiveFluxReconstructor.hpp:(44,17) ConvectiveFluxReconstructor::~ConvectiveFluxReconstructor(ConvectiveFluxReconstructor *)
      -> INLINE: (44,49) std::shared_ptr<SAMRAI::tbox::Database>::~shared_ptr(std::shared_ptr<SAMRAI::tbox::Database> *)
         {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
      -> INLINE: (44,49) std::shared_ptr<FlowModel>::~shared_ptr(std::shared_ptr<FlowModel> *)
         {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
      -> INLINE: (44,49) std::shared_ptr<SAMRAI::geom::CartesianGridGeometry>::~shared_ptr(std::shared_ptr<SAMRAI::geom::CartesianGridGeometry> *)
         {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
      -> INLINE: (44,49) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
         {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (86,1) std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>>::~vector(std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}


    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/shared_ptr_base.h(733,17):remark #34000: call to memset implemented inline with stores with proven (alignment, offset): (32, 8)
/usr/include/c++/4.8.5/bits/shared_ptr_base.h(733,17):remark #34000: call to memset implemented inline with stores with proven (alignment, offset): (32, 8)
/home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(83,1):remark #34051: REGISTER ALLOCATION : [_ZN34ConvectiveFluxReconstructorCentralD1Ev] /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp:83

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rbx rsi rdi r12 r14-r15]
        
    Routine temporaries
        Total         :     100
            Global    :      43
            Local     :      57
        Regenerable   :      21
        Spilled       :       4
        
    Routine stack
        Variables     :      33 bytes*
            Reads     :       4 [4.00e+00 ~ 3.9%]
            Writes    :       8 [8.00e+00 ~ 7.9%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: ConvectiveFluxReconstructorCentral::~ConvectiveFluxReconstructorCentral(ConvectiveFluxReconstructorCentral *const)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (ConvectiveFluxReconstructorCentral::~ConvectiveFluxReconstructorCentral(ConvectiveFluxReconstructorCentral *const)) [34] /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(82,37)
  -> INLINE: (82,37) ConvectiveFluxReconstructorCentral::~ConvectiveFluxReconstructorCentral(ConvectiveFluxReconstructorCentral *)
    -> INLINE: (84,24) std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic>::reset(std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic> *)
       {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
    -> INLINE: (85,22) std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic>::reset(std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic> *)
       {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
    -> INLINE: (86,1) std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>>::~vector(std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>> *)
       {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
    -> INLINE: (86,1) ConvectiveFluxReconstructor::~ConvectiveFluxReconstructor(ConvectiveFluxReconstructor *const)
      -> INLINE: /home/akula/HAMeRS_IB/HAMeRS/include/flow/convective_flux_reconstructors/ConvectiveFluxReconstructor.hpp:(44,17) ConvectiveFluxReconstructor::~ConvectiveFluxReconstructor(ConvectiveFluxReconstructor *)
        -> INLINE: (44,49) std::shared_ptr<SAMRAI::tbox::Database>::~shared_ptr(std::shared_ptr<SAMRAI::tbox::Database> *)
           {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
        -> INLINE: (44,49) std::shared_ptr<FlowModel>::~shared_ptr(std::shared_ptr<FlowModel> *)
           {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
        -> INLINE: (44,49) std::shared_ptr<SAMRAI::geom::CartesianGridGeometry>::~shared_ptr(std::shared_ptr<SAMRAI::geom::CartesianGridGeometry> *)
           {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
        -> INLINE: (44,49) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
           {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}


    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/shared_ptr_base.h(733,17):remark #34000: call to memset implemented inline with stores with proven (alignment, offset): (32, 8)
/usr/include/c++/4.8.5/bits/shared_ptr_base.h(733,17):remark #34000: call to memset implemented inline with stores with proven (alignment, offset): (32, 8)
/home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(82,37):remark #34051: REGISTER ALLOCATION : [_ZN34ConvectiveFluxReconstructorCentralD0Ev] /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp:82

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rbx rsi rdi r12-r14]
        
    Routine temporaries
        Total         :     101
            Global    :      43
            Local     :      58
        Regenerable   :      21
        Spilled       :       4
        
    Routine stack
        Variables     :      33 bytes*
            Reads     :       4 [4.00e+00 ~ 3.9%]
            Writes    :       8 [8.00e+00 ~ 7.7%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: ConvectiveFluxReconstructorCentral::~ConvectiveFluxReconstructorCentral(ConvectiveFluxReconstructorCentral *const)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (ConvectiveFluxReconstructorCentral::~ConvectiveFluxReconstructorCentral(ConvectiveFluxReconstructorCentral *const)) [35] /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(82,37)
  -> INLINE: (82,37) ConvectiveFluxReconstructorCentral::~ConvectiveFluxReconstructorCentral(ConvectiveFluxReconstructorCentral *)
    -> INLINE: (84,24) std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic>::reset(std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic> *)
       {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
    -> INLINE: (85,22) std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic>::reset(std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic> *)
       {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
    -> INLINE: (86,1) std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>>::~vector(std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>> *)
       {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
    -> INLINE: (86,1) ConvectiveFluxReconstructor::~ConvectiveFluxReconstructor(ConvectiveFluxReconstructor *const)
      -> INLINE: /home/akula/HAMeRS_IB/HAMeRS/include/flow/convective_flux_reconstructors/ConvectiveFluxReconstructor.hpp:(44,17) ConvectiveFluxReconstructor::~ConvectiveFluxReconstructor(ConvectiveFluxReconstructor *)
        -> INLINE: (44,49) std::shared_ptr<SAMRAI::tbox::Database>::~shared_ptr(std::shared_ptr<SAMRAI::tbox::Database> *)
           {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
        -> INLINE: (44,49) std::shared_ptr<FlowModel>::~shared_ptr(std::shared_ptr<FlowModel> *)
           {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
        -> INLINE: (44,49) std::shared_ptr<SAMRAI::geom::CartesianGridGeometry>::~shared_ptr(std::shared_ptr<SAMRAI::geom::CartesianGridGeometry> *)
           {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
        -> INLINE: (44,49) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
           {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}


    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/shared_ptr_base.h(733,17):remark #34000: call to memset implemented inline with stores with proven (alignment, offset): (32, 8)
/usr/include/c++/4.8.5/bits/shared_ptr_base.h(733,17):remark #34000: call to memset implemented inline with stores with proven (alignment, offset): (32, 8)
/home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(82,37):remark #34051: REGISTER ALLOCATION : [_ZN34ConvectiveFluxReconstructorCentralD2Ev] /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp:82

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rbx rsi rdi r12 r14-r15]
        
    Routine temporaries
        Total         :     100
            Global    :      43
            Local     :      57
        Regenerable   :      21
        Spilled       :       4
        
    Routine stack
        Variables     :      33 bytes*
            Reads     :       4 [4.00e+00 ~ 3.9%]
            Writes    :       8 [8.00e+00 ~ 7.9%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: ConvectiveFluxReconstructorCentral::printClassData(const ConvectiveFluxReconstructorCentral *, std::ostream &) const

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (ConvectiveFluxReconstructorCentral::printClassData(const ConvectiveFluxReconstructorCentral *, std::ostream &) const) [36] /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(95,1)
  -> (96,8) std::operator<<<std::char_traits<char>>(std::basic_ostream<char, std::char_traits<char>> &, const char *)
  -> (97,8) std::basic_ostream<char, std::char_traits<char>>::operator<<(std::basic_ostream<char, std::char_traits<char>> *, std::basic_ostream<char, std::char_traits<char>>::__ostream_type &(*)(std::basic_ostream<char, std::char_traits<char>>::__ostream_type &))
  -> (99,8) std::basic_ostream<char, std::char_traits<char>>::operator<<(std::basic_ostream<char, std::char_traits<char>> *, std::basic_ostream<char, std::char_traits<char>>::__ostream_type &(*)(std::basic_ostream<char, std::char_traits<char>>::__ostream_type &))
  -> (101,8) std::operator<<<std::char_traits<char>>(std::basic_ostream<char, std::char_traits<char>> &, const char *)
  -> (102,8) std::basic_ostream<char, std::char_traits<char>>::operator<<(std::basic_ostream<char, std::char_traits<char>> *, const void *)
  -> (103,8) std::basic_ostream<char, std::char_traits<char>>::operator<<(std::basic_ostream<char, std::char_traits<char>> *, std::basic_ostream<char, std::char_traits<char>>::__ostream_type &(*)(std::basic_ostream<char, std::char_traits<char>>::__ostream_type &))
  -> (104,8) std::operator<<<std::char_traits<char>>(std::basic_ostream<char, std::char_traits<char>> &, const char *)
  -> (105,8) std::operator<<<char, std::char_traits<char>, std::allocator<char>>(std::basic_ostream<char, std::char_traits<char>> &, const std::basic_string<char, std::char_traits<char>, std::allocator<char>> &)
  -> (106,8) std::basic_ostream<char, std::char_traits<char>>::operator<<(std::basic_ostream<char, std::char_traits<char>> *, std::basic_ostream<char, std::char_traits<char>>::__ostream_type &(*)(std::basic_ostream<char, std::char_traits<char>>::__ostream_type &))
  -> (107,8) std::operator<<<std::char_traits<char>>(std::basic_ostream<char, std::char_traits<char>> &, const char *)
  -> (109,8) std::basic_ostream<char, std::char_traits<char>>::operator<<(std::basic_ostream<char, std::char_traits<char>> *, std::basic_ostream<char, std::char_traits<char>>::__ostream_type &(*)(std::basic_ostream<char, std::char_traits<char>>::__ostream_type &))


    Report from: Code generation optimizations [cg]

/home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(95,1):remark #34051: REGISTER ALLOCATION : [_ZNK34ConvectiveFluxReconstructorCentral14printClassDataERSo] /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp:95

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    5[ rax rbp rsi rdi r12]
        
    Routine temporaries
        Total         :      55
            Global    :      23
            Local     :      32
        Regenerable   :      14
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: ConvectiveFluxReconstructorCentral::putToRestart(const ConvectiveFluxReconstructorCentral *, const std::shared_ptr<SAMRAI::tbox::Database> &) const

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (ConvectiveFluxReconstructorCentral::putToRestart(const ConvectiveFluxReconstructorCentral *, const std::shared_ptr<SAMRAI::tbox::Database> &) const) [42] /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(120,1)
  -> INLINE: (121,15) std::__shared_ptr<SAMRAI::tbox::Database, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::tbox::Database, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (121,28) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (121,28) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (121,28) std::allocator<char>::allocator(std::allocator<char> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (121,39) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (121,39) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INDIRECT- (VIRTUAL): (121,39)  EXPR_CONV.SI64.P64(*((SI64*) (__$Ua5_V$cbe.0.612->__vptr_V$c90 + EXPR_CONV.SI32.I64(62(SI32)) * 8(I64))))


    Report from: Code generation optimizations [cg]

/home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(120,1):remark #34051: REGISTER ALLOCATION : [_ZNK34ConvectiveFluxReconstructorCentral12putToRestartERKSt10shared_ptrIN6SAMRAI4tbox8DatabaseEE] /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp:120

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    7[ rax rdx rcx rbx rsi rdi r13]
        
    Routine temporaries
        Total         :      54
            Global    :      17
            Local     :      37
        Regenerable   :      16
        Spilled       :       2
        
    Routine stack
        Variables     :      19 bytes*
            Reads     :       3 [1.00e+00 ~ 2.6%]
            Writes    :       2 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: ConvectiveFluxReconstructorCentral::computeConvectiveFluxAndSourceOnPatch(ConvectiveFluxReconstructorCentral *, SAMRAI::hier::Patch &, const std::shared_ptr<SAMRAI::pdat::SideVariable<Real>> &, const std::shared_ptr<SAMRAI::pdat::CellVariable<Real>> &, const std::shared_ptr<SAMRAI::hier::VariableContext> &, double, double, int)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (ConvectiveFluxReconstructorCentral::computeConvectiveFluxAndSourceOnPatch(ConvectiveFluxReconstructorCentral *, SAMRAI::hier::Patch &, const std::shared_ptr<SAMRAI::pdat::SideVariable<Real>> &, const std::shared_ptr<SAMRAI::pdat::CellVariable<Real>> &, const std::shared_ptr<SAMRAI::hier::VariableContext> &, double, double, int)) [43] /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(137,1)
  -> INLINE: (223,9) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (223,9) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (223,9) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (223,9) std::basic_ostringstream<char, std::char_traits<char>, std::allocator<char>>::~basic_ostringstream(std::basic_ostringstream<char, std::char_traits<char>, std::allocator<char>> *const)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (223,9) std::basic_ostringstream<char, std::char_traits<char>, std::allocator<char>>::str(std::basic_ostringstream<char, std::char_traits<char>, std::allocator<char>>::__string_type *, const std::basic_ostringstream<char, std::char_traits<char>, std::allocator<char>> *) const
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (223,9) std::allocator<char>::allocator(std::allocator<char> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (223,9) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (223,9) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (223,9) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (223,9) std::basic_ostringstream<char, std::char_traits<char>, std::allocator<char>>::~basic_ostringstream(std::basic_ostringstream<char, std::char_traits<char>, std::allocator<char>> *const)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> (223,9) std::operator<<<std::char_traits<char>>(std::basic_ostream<char, std::char_traits<char>> &, const char *)
  -> INLINE: (223,9) std::basic_ostringstream<char, std::char_traits<char>, std::allocator<char>>::basic_ostringstream(std::basic_ostringstream<char, std::char_traits<char>, std::allocator<char>> *const, std::ios_base::openmode)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (228,36) SAMRAI::hier::Patch::getBox(const SAMRAI::hier::Patch *) const
  -> (229,56) SAMRAI::hier::Box::numberCells(SAMRAI::hier::IntVector *, const SAMRAI::hier::Box *) const
  -> (234,20) SAMRAI::hier::Box::grow(SAMRAI::hier::Box *, const SAMRAI::hier::IntVector &)
  -> (235,64) SAMRAI::hier::Box::numberCells(SAMRAI::hier::IntVector *, const SAMRAI::hier::Box *) const
  -> (238,59) std::shared_ptr<SAMRAI::hier::PatchGeometry>::~shared_ptr(std::shared_ptr<SAMRAI::hier::PatchGeometry> *)
  -> (239,9) std::static_pointer_cast<SAMRAI::geom::CartesianPatchGeometry, SAMRAI::hier::PatchGeometry>(std::shared_ptr<SAMRAI::geom::CartesianPatchGeometry> *, const std::shared_ptr<SAMRAI::hier::PatchGeometry> &)
  -> (239,9) std::shared_ptr<SAMRAI::geom::CartesianPatchGeometry>::~shared_ptr(std::shared_ptr<SAMRAI::geom::CartesianPatchGeometry> *)
  -> (240,19) SAMRAI::hier::Patch::getPatchGeometry(std::shared_ptr<SAMRAI::hier::PatchGeometry> *, const SAMRAI::hier::Patch *) const
  -> INLINE: (242,40) std::__shared_ptr<SAMRAI::geom::CartesianPatchGeometry, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::geom::CartesianPatchGeometry, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (242,42) SAMRAI::geom::CartesianPatchGeometry::getDx(const SAMRAI::geom::CartesianPatchGeometry *) const
  -> (245,46) std::shared_ptr<SAMRAI::hier::PatchData>::~shared_ptr(std::shared_ptr<SAMRAI::hier::PatchData> *)
  -> (245,46) std::shared_ptr<SAMRAI::hier::Variable>::~shared_ptr(std::shared_ptr<SAMRAI::hier::Variable> *)
  -> (246,9) std::static_pointer_cast<SAMRAI::pdat::SideData<Real>, SAMRAI::hier::PatchData>(std::shared_ptr<SAMRAI::pdat::SideData<Real>> *, const std::shared_ptr<SAMRAI::hier::PatchData> &)
  -> (246,9) std::shared_ptr<SAMRAI::pdat::SideData<Real>>::~shared_ptr(std::shared_ptr<SAMRAI::pdat::SideData<Real>> *)
  -> (247,19) SAMRAI::hier::Patch::getPatchData(std::shared_ptr<SAMRAI::hier::PatchData> *, const SAMRAI::hier::Patch *, const std::shared_ptr<SAMRAI::hier::Variable> &, const std::shared_ptr<SAMRAI::hier::VariableContext> &) const
  -> (247,32) std::shared_ptr<SAMRAI::hier::Variable>::~shared_ptr(std::shared_ptr<SAMRAI::hier::Variable> *)
  -> (247,32) std::shared_ptr<SAMRAI::hier::Variable>::shared_ptr<SAMRAI::pdat::SideVariable<Real>, void>(std::shared_ptr<SAMRAI::hier::Variable> *, const std::shared_ptr<SAMRAI::pdat::SideVariable<Real>> &)
  -> (250,46) std::shared_ptr<SAMRAI::hier::PatchData>::~shared_ptr(std::shared_ptr<SAMRAI::hier::PatchData> *)
  -> (250,46) std::shared_ptr<SAMRAI::hier::Variable>::~shared_ptr(std::shared_ptr<SAMRAI::hier::Variable> *)
  -> (251,9) std::static_pointer_cast<SAMRAI::pdat::CellData<Real>, SAMRAI::hier::PatchData>(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *, const std::shared_ptr<SAMRAI::hier::PatchData> &)
  -> (251,9) std::shared_ptr<SAMRAI::pdat::CellData<Real>>::~shared_ptr(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *)
  -> (252,19) SAMRAI::hier::Patch::getPatchData(std::shared_ptr<SAMRAI::hier::PatchData> *, const SAMRAI::hier::Patch *, const std::shared_ptr<SAMRAI::hier::Variable> &, const std::shared_ptr<SAMRAI::hier::VariableContext> &) const
  -> (252,32) std::shared_ptr<SAMRAI::hier::Variable>::~shared_ptr(std::shared_ptr<SAMRAI::hier::Variable> *)
  -> (252,32) std::shared_ptr<SAMRAI::hier::Variable>::shared_ptr<SAMRAI::pdat::CellVariable<Real>, void>(std::shared_ptr<SAMRAI::hier::Variable> *, const std::shared_ptr<SAMRAI::pdat::CellVariable<Real>> &)
  -> (262,5) std::shared_ptr<SAMRAI::geom::CartesianPatchGeometry>::~shared_ptr(std::shared_ptr<SAMRAI::geom::CartesianPatchGeometry> *)
  -> (262,5) std::shared_ptr<SAMRAI::pdat::SideData<Real>>::~shared_ptr(std::shared_ptr<SAMRAI::pdat::SideData<Real>> *)
  -> (262,5) std::shared_ptr<SAMRAI::pdat::CellData<Real>>::~shared_ptr(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *)
  -> INLINE: (262,15) SAMRAI::tbox::Dimension::operator==(const SAMRAI::tbox::Dimension *, const SAMRAI::tbox::Dimension &) const
  -> INLINE: (268,49) SAMRAI::hier::IntVector::operator[](const SAMRAI::hier::IntVector *, unsigned int) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(272,22) std::vector<int, std::allocator<int>>::operator[](const std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type) const
  -> INLINE: (274,21) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> INDIRECT- (VIRTUAL): (274,59)  EXPR_CONV.SI64.P64(*((SI64*) (__$Ub0_V$ceb.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(13(SI32)) * 8(I64))))
  -> (276,58) std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::~unordered_map(std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>> *)
  -> DELETED: (276,58) std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>::~allocator(std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>> *)
  -> (276,58) std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>::allocator(std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>> *)
  -> (276,58) std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::unordered_map(std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>> *, std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::size_type, const std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::hasher &, const std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::key_equal &, const std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::allocator_type &)
  -> DELETED: (276,58) std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>::~allocator(std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>> *)
  -> (278,38) std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::insert<std::pair<std::string, SAMRAI::hier::IntVector>, void>(std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>> *, std::pair<std::string, SAMRAI::hier::IntVector> &&)
  -> (278,38) std::pair<std::string, SAMRAI::hier::IntVector>::~pair(std::pair<std::string, SAMRAI::hier::IntVector> *)
  -> (278,99) std::pair<std::string, SAMRAI::hier::IntVector>::~pair(std::pair<std::string, SAMRAI::hier::IntVector> *)
  -> (278,99) std::pair<std::string, SAMRAI::hier::IntVector>::pair<const char (&)[18], SAMRAI::hier::IntVector &, void>(std::pair<std::string, SAMRAI::hier::IntVector> *, const char (&)[18], SAMRAI::hier::IntVector &)
  -> (282,42) std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::insert<std::pair<std::string, SAMRAI::hier::IntVector>, void>(std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>> *, std::pair<std::string, SAMRAI::hier::IntVector> &&)
  -> (282,42) std::pair<std::string, SAMRAI::hier::IntVector>::~pair(std::pair<std::string, SAMRAI::hier::IntVector> *)
  -> (282,94) std::pair<std::string, SAMRAI::hier::IntVector>::~pair(std::pair<std::string, SAMRAI::hier::IntVector> *)
  -> (282,94) std::pair<std::string, SAMRAI::hier::IntVector>::pair<const char (&)[9], SAMRAI::hier::IntVector &, void>(std::pair<std::string, SAMRAI::hier::IntVector> *, const char (&)[9], SAMRAI::hier::IntVector &)
  -> INLINE: (285,21) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> INDIRECT- (VIRTUAL): (285,48)  EXPR_CONV.SI64.P64(*((SI64*) (__$Ub5_V$cf0.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(14(SI32)) * 8(I64))))
  -> INLINE: (287,21) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> INDIRECT- (VIRTUAL): (287,21)  EXPR_CONV.SI64.P64(*((SI64*) (__$Ub6_V$cf1.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(16(SI32)) * 8(I64))))
  -> INLINE: (289,21) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> INDIRECT- (VIRTUAL): (289,21)  EXPR_CONV.SI64.P64(*((SI64*) (__$Ub7_V$cf2.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(17(SI32)) * 8(I64))))
  -> DELETED: (296,64) std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>::~allocator(std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>> *)
  -> DELETED: (296,85) std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>::~allocator(std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>> *)
  -> (296,85) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::~vector(std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *)
  -> (296,85) std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>::allocator(std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>> *)
  -> (296,85) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::vector(std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type, const std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::allocator_type &)
  -> INLINE: (297,29) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> (297,33) std::shared_ptr<SAMRAI::pdat::CellData<Real>>::operator=(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *, std::shared_ptr<SAMRAI::pdat::CellData<Real>> &&)
  -> (297,33) std::shared_ptr<SAMRAI::pdat::CellData<Real>>::~shared_ptr(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *)
  -> INLINE: (297,33) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (297,33) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (297,47) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (297,61) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (297,61) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (297,61) std::allocator<char>::allocator(std::allocator<char> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INDIRECT- (VIRTUAL): (297,61)  EXPR_CONV.SI64.P64(*((SI64*) (__$Ubc_V$cf7.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(18(SI32)) * 8(I64))))
  -> INLINE: (299,79) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (299,82) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (299,84) SAMRAI::hier::PatchData::getGhostCellWidth(const SAMRAI::hier::PatchData *) const
  -> INLINE: (300,86) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> (302,28) std::vector<Real *, std::allocator<Real *>>::~vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (302,28) std::vector<Real *, std::allocator<Real *>>::vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (303,18) std::vector<Real *, std::allocator<Real *>>::reserve(std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> (306,22) std::vector<Real *, std::allocator<Real *>>::push_back(std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::value_type &&)
  -> INLINE: (306,52) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (306,55) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (306,57) SAMRAI::pdat::CellData<Real>::getPointer(SAMRAI::pdat::CellData<Real> *, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,17) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,19) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (309,27) std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (319,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (319,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (331,38) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (331,65) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (340,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (340,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (354,38) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (354,66) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (355,38) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (355,66) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (364,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (364,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (380,38) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (380,67) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (381,38) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (381,67) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (382,38) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (382,67) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (391,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (391,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (409,38) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (409,68) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (410,38) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (410,68) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (411,38) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (411,68) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (412,38) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (412,68) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (421,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (421,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (441,38) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (441,69) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (442,38) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (442,69) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (443,38) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (443,69) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (444,38) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (444,69) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (445,38) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (445,69) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (454,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (454,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (476,38) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (476,70) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (477,38) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (477,70) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (478,38) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (478,70) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (479,38) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (479,70) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (480,38) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (480,70) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (481,38) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (481,70) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (487,27) std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (493,25) std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic> *) const
  -> DELETED: (497,54) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (497,54) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (497,77) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> (497,91) std::shared_ptr<SAMRAI::pdat::CellData<Real>>::~shared_ptr(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *)
  -> INLINE: (497,91) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (497,91) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INDIRECT- (VIRTUAL): (497,91)  EXPR_CONV.SI64.P64(*((SI64*) (__$Uc2_V$d4b.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(18(SI32)) * 8(I64))))
  -> INLINE: (497,91) std::allocator<char>::allocator(std::allocator<char> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (499,62) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (499,64) SAMRAI::hier::PatchData::getGhostCellWidth(const SAMRAI::hier::PatchData *) const
  -> INLINE: (500,72) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (502,31) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (502,33) SAMRAI::pdat::CellData<Real>::getPointer(SAMRAI::pdat::CellData<Real> *, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,17) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,19) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> (504,42) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::~vector(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *)
  -> (504,42) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::vector(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *)
  -> (505,44) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::reserve(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *, std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::size_type)
  -> INLINE: (508,29) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> (508,29) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::~vector(std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *)
  -> INDIRECT- (VIRTUAL): (508,29)  EXPR_CONV.SI64.P64(*((SI64*) (__$Uc3_V$d4c.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(23(SI32)) * 8(I64))))
  -> (510,32) std::vector<Real *, std::allocator<Real *>>::~vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (510,32) std::vector<Real *, std::allocator<Real *>>::vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (511,15) std::vector<Real *, std::allocator<Real *>>::reserve(std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (515,75) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size(const std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *) const
  -> INLINE: (515,75) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size(const std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *) const
  -> INLINE: (517,51) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (517,55) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (517,57) SAMRAI::pdat::CellData<Real>::getDepth(const SAMRAI::pdat::CellData<Real> *) const
  -> (526,23) std::vector<Real *, std::allocator<Real *>>::push_back(std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::value_type &&)
  -> INLINE: (526,55) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (526,59) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (526,61) SAMRAI::pdat::CellData<Real>::getPointer(SAMRAI::pdat::CellData<Real> *, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,17) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,19) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> (527,52) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::push_back(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *, const std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::value_type &)
  -> INLINE: (527,84) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (527,88) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (527,90) SAMRAI::hier::PatchData::getGhostCellWidth(const SAMRAI::hier::PatchData *) const
  -> INLINE: (535,31) std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>>::operator[](std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>> *, std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>>::size_type)
  -> INLINE: (537,37) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (537,39) SAMRAI::pdat::CellData<Real>::getPointer(SAMRAI::pdat::CellData<Real> *, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,17) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,19) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (539,96) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::operator[](std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *, std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::size_type)
  -> INLINE: (539,100) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (554,61) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (575,61) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (599,61) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (626,61) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (656,61) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (689,61) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> (702,9) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::~vector(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *)
  -> (702,9) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::~vector(std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *)
  -> (702,9) std::vector<Real *, std::allocator<Real *>>::~vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (702,9) std::shared_ptr<SAMRAI::pdat::CellData<Real>>::~shared_ptr(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *)
  -> INLINE: (704,25) std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (710,21) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> INDIRECT- (VIRTUAL): (710,21)  EXPR_CONV.SI64.P64(*((SI64*) (__$Ubd_V$cf8.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(15(SI32)) * 8(I64))))
  -> (712,5) std::vector<Real *, std::allocator<Real *>>::~vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (712,5) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::~vector(std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *)
  -> (712,5) std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::~unordered_map(std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>> *)
  -> INLINE: (713,20) SAMRAI::tbox::Dimension::operator==(const SAMRAI::tbox::Dimension *, const SAMRAI::tbox::Dimension &) const
  -> INLINE: (719,49) SAMRAI::hier::IntVector::operator[](const SAMRAI::hier::IntVector *, unsigned int) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(272,22) std::vector<int, std::allocator<int>>::operator[](const std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type) const
  -> INLINE: (720,49) SAMRAI::hier::IntVector::operator[](const SAMRAI::hier::IntVector *, unsigned int) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(272,22) std::vector<int, std::allocator<int>>::operator[](const std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type) const
  -> INLINE: (726,21) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> INDIRECT- (VIRTUAL): (726,59)  EXPR_CONV.SI64.P64(*((SI64*) (__$Uc7_V$d9b.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(13(SI32)) * 8(I64))))
  -> (728,58) std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::~unordered_map(std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>> *)
  -> DELETED: (728,58) std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>::~allocator(std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>> *)
  -> (728,58) std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>::allocator(std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>> *)
  -> (728,58) std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::unordered_map(std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>> *, std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::size_type, const std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::hasher &, const std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::key_equal &, const std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::allocator_type &)
  -> DELETED: (728,58) std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>::~allocator(std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>> *)
  -> (730,38) std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::insert<std::pair<std::string, SAMRAI::hier::IntVector>, void>(std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>> *, std::pair<std::string, SAMRAI::hier::IntVector> &&)
  -> (730,38) std::pair<std::string, SAMRAI::hier::IntVector>::~pair(std::pair<std::string, SAMRAI::hier::IntVector> *)
  -> (730,99) std::pair<std::string, SAMRAI::hier::IntVector>::~pair(std::pair<std::string, SAMRAI::hier::IntVector> *)
  -> (730,99) std::pair<std::string, SAMRAI::hier::IntVector>::pair<const char (&)[18], SAMRAI::hier::IntVector &, void>(std::pair<std::string, SAMRAI::hier::IntVector> *, const char (&)[18], SAMRAI::hier::IntVector &)
  -> (731,38) std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::insert<std::pair<std::string, SAMRAI::hier::IntVector>, void>(std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>> *, std::pair<std::string, SAMRAI::hier::IntVector> &&)
  -> (731,38) std::pair<std::string, SAMRAI::hier::IntVector>::~pair(std::pair<std::string, SAMRAI::hier::IntVector> *)
  -> (731,99) std::pair<std::string, SAMRAI::hier::IntVector>::~pair(std::pair<std::string, SAMRAI::hier::IntVector> *)
  -> (731,99) std::pair<std::string, SAMRAI::hier::IntVector>::pair<const char (&)[18], SAMRAI::hier::IntVector &, void>(std::pair<std::string, SAMRAI::hier::IntVector> *, const char (&)[18], SAMRAI::hier::IntVector &)
  -> (735,42) std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::insert<std::pair<std::string, SAMRAI::hier::IntVector>, void>(std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>> *, std::pair<std::string, SAMRAI::hier::IntVector> &&)
  -> (735,42) std::pair<std::string, SAMRAI::hier::IntVector>::~pair(std::pair<std::string, SAMRAI::hier::IntVector> *)
  -> (735,94) std::pair<std::string, SAMRAI::hier::IntVector>::~pair(std::pair<std::string, SAMRAI::hier::IntVector> *)
  -> (735,94) std::pair<std::string, SAMRAI::hier::IntVector>::pair<const char (&)[9], SAMRAI::hier::IntVector &, void>(std::pair<std::string, SAMRAI::hier::IntVector> *, const char (&)[9], SAMRAI::hier::IntVector &)
  -> INLINE: (738,21) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> INDIRECT- (VIRTUAL): (738,48)  EXPR_CONV.SI64.P64(*((SI64*) (__$Ucc_V$da0.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(14(SI32)) * 8(I64))))
  -> INLINE: (740,21) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> INDIRECT- (VIRTUAL): (740,21)  EXPR_CONV.SI64.P64(*((SI64*) (__$Ucd_V$da1.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(16(SI32)) * 8(I64))))
  -> INLINE: (742,21) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> INDIRECT- (VIRTUAL): (742,21)  EXPR_CONV.SI64.P64(*((SI64*) (__$Uce_V$da2.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(17(SI32)) * 8(I64))))
  -> DELETED: (749,64) std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>::~allocator(std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>> *)
  -> DELETED: (749,85) std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>::~allocator(std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>> *)
  -> (749,85) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::~vector(std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *)
  -> (749,85) std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>::allocator(std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>> *)
  -> (749,85) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::vector(std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type, const std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::allocator_type &)
  -> INLINE: (750,29) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> (750,33) std::shared_ptr<SAMRAI::pdat::CellData<Real>>::operator=(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *, std::shared_ptr<SAMRAI::pdat::CellData<Real>> &&)
  -> (750,33) std::shared_ptr<SAMRAI::pdat::CellData<Real>>::~shared_ptr(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *)
  -> INLINE: (750,33) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (750,33) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (750,47) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (750,61) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (750,61) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (750,61) std::allocator<char>::allocator(std::allocator<char> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INDIRECT- (VIRTUAL): (750,61)  EXPR_CONV.SI64.P64(*((SI64*) (__$Ud3_V$da7.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(18(SI32)) * 8(I64))))
  -> INLINE: (751,29) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> (751,33) std::shared_ptr<SAMRAI::pdat::CellData<Real>>::operator=(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *, std::shared_ptr<SAMRAI::pdat::CellData<Real>> &&)
  -> (751,33) std::shared_ptr<SAMRAI::pdat::CellData<Real>>::~shared_ptr(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *)
  -> INLINE: (751,33) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (751,33) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (751,47) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (751,61) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (751,61) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (751,61) std::allocator<char>::allocator(std::allocator<char> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INDIRECT- (VIRTUAL): (751,61)  EXPR_CONV.SI64.P64(*((SI64*) (__$Ud4_V$da8.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(18(SI32)) * 8(I64))))
  -> INLINE: (753,79) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (753,82) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (753,84) SAMRAI::hier::PatchData::getGhostCellWidth(const SAMRAI::hier::PatchData *) const
  -> INLINE: (754,83) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (754,86) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (754,88) SAMRAI::hier::PatchData::getGhostBox(const SAMRAI::hier::PatchData *) const
  -> (754,102) SAMRAI::hier::Box::numberCells(SAMRAI::hier::IntVector *, const SAMRAI::hier::Box *) const
  -> INLINE: (756,79) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (756,82) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (756,84) SAMRAI::hier::PatchData::getGhostCellWidth(const SAMRAI::hier::PatchData *) const
  -> INLINE: (757,83) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (757,86) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (757,88) SAMRAI::hier::PatchData::getGhostBox(const SAMRAI::hier::PatchData *) const
  -> (757,102) SAMRAI::hier::Box::numberCells(SAMRAI::hier::IntVector *, const SAMRAI::hier::Box *) const
  -> INLINE: (759,86) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (760,86) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (761,93) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (763,86) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (764,86) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (765,93) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> (767,28) std::vector<Real *, std::allocator<Real *>>::~vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (767,28) std::vector<Real *, std::allocator<Real *>>::vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (768,28) std::vector<Real *, std::allocator<Real *>>::~vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (768,28) std::vector<Real *, std::allocator<Real *>>::vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (769,18) std::vector<Real *, std::allocator<Real *>>::reserve(std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> (770,18) std::vector<Real *, std::allocator<Real *>>::reserve(std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> (773,22) std::vector<Real *, std::allocator<Real *>>::push_back(std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::value_type &&)
  -> INLINE: (773,52) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (773,55) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (773,57) SAMRAI::pdat::CellData<Real>::getPointer(SAMRAI::pdat::CellData<Real> *, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,17) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,19) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> (774,22) std::vector<Real *, std::allocator<Real *>>::push_back(std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::value_type &&)
  -> INLINE: (774,52) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (774,55) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (774,57) SAMRAI::pdat::CellData<Real>::getPointer(SAMRAI::pdat::CellData<Real> *, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,17) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,19) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (777,27) std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (787,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (787,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (805,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (805,69) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (815,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (815,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (839,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (839,70) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (840,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (840,70) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (850,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (850,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (880,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (880,71) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (881,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (881,71) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (882,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (882,71) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (892,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (892,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (928,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (928,72) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (929,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (929,72) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (930,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (930,72) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (931,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (931,72) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (941,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (941,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (983,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (983,73) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (984,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (984,73) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (985,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (985,73) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (986,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (986,73) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (987,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (987,73) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (997,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (997,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (1045,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1045,74) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1046,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1046,74) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1047,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1047,74) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1048,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1048,74) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1049,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1049,74) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1050,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1050,74) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1065,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1065,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (1083,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1083,69) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1093,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1093,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (1117,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1117,70) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1118,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1118,70) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1128,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1128,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (1158,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1158,71) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1159,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1159,71) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1160,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1160,71) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1170,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1170,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (1206,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1206,72) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1207,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1207,72) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1208,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1208,72) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1209,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1209,72) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1219,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1219,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (1261,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1261,73) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1262,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1262,73) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1263,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1263,73) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1264,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1264,73) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1265,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1265,73) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1275,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1275,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (1323,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1323,74) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1324,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1324,74) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1325,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1325,74) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1326,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1326,74) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1327,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1327,74) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1328,42) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1328,74) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1335,27) std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1341,25) std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic> *) const
  -> DELETED: (1345,54) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (1345,54) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (1345,77) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> (1345,91) std::shared_ptr<SAMRAI::pdat::CellData<Real>>::~shared_ptr(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *)
  -> INLINE: (1345,91) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (1345,91) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INDIRECT- (VIRTUAL): (1345,91)  EXPR_CONV.SI64.P64(*((SI64*) (__$Uda_V$e53.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(18(SI32)) * 8(I64))))
  -> INLINE: (1345,91) std::allocator<char>::allocator(std::allocator<char> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (1347,62) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1347,64) SAMRAI::hier::PatchData::getGhostCellWidth(const SAMRAI::hier::PatchData *) const
  -> INLINE: (1348,66) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1348,68) SAMRAI::hier::PatchData::getGhostBox(const SAMRAI::hier::PatchData *) const
  -> (1348,82) SAMRAI::hier::Box::numberCells(SAMRAI::hier::IntVector *, const SAMRAI::hier::Box *) const
  -> INLINE: (1350,72) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (1351,72) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (1352,79) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (1354,31) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1354,33) SAMRAI::pdat::CellData<Real>::getPointer(SAMRAI::pdat::CellData<Real> *, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,17) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,19) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (1355,31) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1355,33) SAMRAI::pdat::CellData<Real>::getPointer(SAMRAI::pdat::CellData<Real> *, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,17) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,19) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> (1357,42) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::~vector(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *)
  -> (1357,42) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::vector(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *)
  -> (1358,44) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::reserve(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *, std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::size_type)
  -> (1360,42) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::~vector(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *)
  -> (1360,42) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::vector(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *)
  -> (1361,48) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::reserve(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *, std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::size_type)
  -> INLINE: (1364,29) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> (1364,29) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::~vector(std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *)
  -> INDIRECT- (VIRTUAL): (1364,29)  EXPR_CONV.SI64.P64(*((SI64*) (__$Udb_V$e54.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(23(SI32)) * 8(I64))))
  -> (1366,32) std::vector<Real *, std::allocator<Real *>>::~vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (1366,32) std::vector<Real *, std::allocator<Real *>>::vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (1367,15) std::vector<Real *, std::allocator<Real *>>::reserve(std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1371,75) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size(const std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *) const
  -> INLINE: (1371,75) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size(const std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *) const
  -> INLINE: (1373,51) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (1373,55) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1373,57) SAMRAI::pdat::CellData<Real>::getDepth(const SAMRAI::pdat::CellData<Real> *) const
  -> (1382,23) std::vector<Real *, std::allocator<Real *>>::push_back(std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::value_type &&)
  -> INLINE: (1382,55) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (1382,59) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1382,61) SAMRAI::pdat::CellData<Real>::getPointer(SAMRAI::pdat::CellData<Real> *, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,17) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,19) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> (1383,52) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::push_back(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *, const std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::value_type &)
  -> INLINE: (1383,84) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (1383,88) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1383,90) SAMRAI::hier::PatchData::getGhostCellWidth(const SAMRAI::hier::PatchData *) const
  -> (1384,56) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::push_back(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *, std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::value_type &&)
  -> INLINE: (1385,47) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (1385,51) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1385,53) SAMRAI::hier::PatchData::getGhostBox(const SAMRAI::hier::PatchData *) const
  -> (1385,67) SAMRAI::hier::Box::numberCells(SAMRAI::hier::IntVector *, const SAMRAI::hier::Box *) const
  -> INLINE: (1393,31) std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>>::operator[](std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>> *, std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>>::size_type)
  -> INLINE: (1395,37) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1395,39) SAMRAI::pdat::CellData<Real>::getPointer(SAMRAI::pdat::CellData<Real> *, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,17) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,19) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (1397,96) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::operator[](std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *, std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::size_type)
  -> INLINE: (1397,100) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (1398,96) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::operator[](std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *, std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::size_type)
  -> INLINE: (1398,100) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (1399,103) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::operator[](std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *, std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::size_type)
  -> INLINE: (1399,107) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (1426,65) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1474,65) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1536,65) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1612,65) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1702,65) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1806,65) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> (1829,9) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::~vector(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *)
  -> (1829,9) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::~vector(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *)
  -> (1829,9) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::~vector(std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *)
  -> (1829,9) std::vector<Real *, std::allocator<Real *>>::~vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (1829,9) std::shared_ptr<SAMRAI::pdat::CellData<Real>>::~shared_ptr(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *)
  -> INLINE: (1831,25) std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1837,21) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> INDIRECT- (VIRTUAL): (1837,21)  EXPR_CONV.SI64.P64(*((SI64*) (__$Ud5_V$da9.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(15(SI32)) * 8(I64))))
  -> (1839,5) std::vector<Real *, std::allocator<Real *>>::~vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (1839,5) std::vector<Real *, std::allocator<Real *>>::~vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (1839,5) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::~vector(std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *)
  -> (1839,5) std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::~unordered_map(std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>> *)
  -> INLINE: (1840,20) SAMRAI::tbox::Dimension::operator==(const SAMRAI::tbox::Dimension *, const SAMRAI::tbox::Dimension &) const
  -> INLINE: (1846,49) SAMRAI::hier::IntVector::operator[](const SAMRAI::hier::IntVector *, unsigned int) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(272,22) std::vector<int, std::allocator<int>>::operator[](const std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type) const
  -> INLINE: (1847,49) SAMRAI::hier::IntVector::operator[](const SAMRAI::hier::IntVector *, unsigned int) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(272,22) std::vector<int, std::allocator<int>>::operator[](const std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type) const
  -> INLINE: (1848,49) SAMRAI::hier::IntVector::operator[](const SAMRAI::hier::IntVector *, unsigned int) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(272,22) std::vector<int, std::allocator<int>>::operator[](const std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type) const
  -> INLINE: (1854,21) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> INDIRECT- (VIRTUAL): (1854,59)  EXPR_CONV.SI64.P64(*((SI64*) (__$Ue0_V$eda.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(13(SI32)) * 8(I64))))
  -> DELETED: (1856,58) std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>::~allocator(std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>> *)
  -> (1856,58) std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>::allocator(std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>> *)
  -> (1856,58) std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::unordered_map(std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>> *, std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::size_type, const std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::hasher &, const std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::key_equal &, const std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::allocator_type &)
  -> DELETED: (1856,58) std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>::~allocator(std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>> *)
  -> (1856,58) std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::~unordered_map(std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>> *)
  -> (1858,38) std::pair<std::string, SAMRAI::hier::IntVector>::~pair(std::pair<std::string, SAMRAI::hier::IntVector> *)
  -> (1858,38) std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::insert<std::pair<std::string, SAMRAI::hier::IntVector>, void>(std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>> *, std::pair<std::string, SAMRAI::hier::IntVector> &&)
  -> (1858,99) std::pair<std::string, SAMRAI::hier::IntVector>::~pair(std::pair<std::string, SAMRAI::hier::IntVector> *)
  -> (1858,99) std::pair<std::string, SAMRAI::hier::IntVector>::pair<const char (&)[18], SAMRAI::hier::IntVector &, void>(std::pair<std::string, SAMRAI::hier::IntVector> *, const char (&)[18], SAMRAI::hier::IntVector &)
  -> (1859,38) std::pair<std::string, SAMRAI::hier::IntVector>::~pair(std::pair<std::string, SAMRAI::hier::IntVector> *)
  -> (1859,38) std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::insert<std::pair<std::string, SAMRAI::hier::IntVector>, void>(std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>> *, std::pair<std::string, SAMRAI::hier::IntVector> &&)
  -> (1859,99) std::pair<std::string, SAMRAI::hier::IntVector>::~pair(std::pair<std::string, SAMRAI::hier::IntVector> *)
  -> (1859,99) std::pair<std::string, SAMRAI::hier::IntVector>::pair<const char (&)[18], SAMRAI::hier::IntVector &, void>(std::pair<std::string, SAMRAI::hier::IntVector> *, const char (&)[18], SAMRAI::hier::IntVector &)
  -> (1860,38) std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::insert<std::pair<std::string, SAMRAI::hier::IntVector>, void>(std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>> *, std::pair<std::string, SAMRAI::hier::IntVector> &&)
  -> (1860,38) std::pair<std::string, SAMRAI::hier::IntVector>::~pair(std::pair<std::string, SAMRAI::hier::IntVector> *)
  -> (1860,99) std::pair<std::string, SAMRAI::hier::IntVector>::~pair(std::pair<std::string, SAMRAI::hier::IntVector> *)
  -> (1860,99) std::pair<std::string, SAMRAI::hier::IntVector>::pair<const char (&)[18], SAMRAI::hier::IntVector &, void>(std::pair<std::string, SAMRAI::hier::IntVector> *, const char (&)[18], SAMRAI::hier::IntVector &)
  -> (1864,42) std::pair<std::string, SAMRAI::hier::IntVector>::~pair(std::pair<std::string, SAMRAI::hier::IntVector> *)
  -> (1864,42) std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::insert<std::pair<std::string, SAMRAI::hier::IntVector>, void>(std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>> *, std::pair<std::string, SAMRAI::hier::IntVector> &&)
  -> (1864,94) std::pair<std::string, SAMRAI::hier::IntVector>::~pair(std::pair<std::string, SAMRAI::hier::IntVector> *)
  -> (1864,94) std::pair<std::string, SAMRAI::hier::IntVector>::pair<const char (&)[9], SAMRAI::hier::IntVector &, void>(std::pair<std::string, SAMRAI::hier::IntVector> *, const char (&)[9], SAMRAI::hier::IntVector &)
  -> INLINE: (1867,21) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> INDIRECT- (VIRTUAL): (1867,48)  EXPR_CONV.SI64.P64(*((SI64*) (__$Ue5_V$edf.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(14(SI32)) * 8(I64))))
  -> INLINE: (1869,21) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> INDIRECT- (VIRTUAL): (1869,21)  EXPR_CONV.SI64.P64(*((SI64*) (__$Ue6_V$ee0.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(16(SI32)) * 8(I64))))
  -> INLINE: (1871,21) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> INDIRECT- (VIRTUAL): (1871,21)  EXPR_CONV.SI64.P64(*((SI64*) (__$Ue7_V$ee1.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(17(SI32)) * 8(I64))))
  -> DELETED: (1878,64) std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>::~allocator(std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>> *)
  -> DELETED: (1878,85) std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>::~allocator(std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>> *)
  -> (1878,85) std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>::allocator(std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>> *)
  -> (1878,85) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::vector(std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type, const std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::allocator_type &)
  -> (1878,85) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::~vector(std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *)
  -> INLINE: (1879,29) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> (1879,33) std::shared_ptr<SAMRAI::pdat::CellData<Real>>::operator=(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *, std::shared_ptr<SAMRAI::pdat::CellData<Real>> &&)
  -> (1879,33) std::shared_ptr<SAMRAI::pdat::CellData<Real>>::~shared_ptr(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *)
  -> INLINE: (1879,33) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (1879,33) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (1879,47) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1879,61) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (1879,61) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (1879,61) std::allocator<char>::allocator(std::allocator<char> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INDIRECT- (VIRTUAL): (1879,61)  EXPR_CONV.SI64.P64(*((SI64*) (__$Uec_V$ee6.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(18(SI32)) * 8(I64))))
  -> INLINE: (1880,29) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> (1880,33) std::shared_ptr<SAMRAI::pdat::CellData<Real>>::operator=(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *, std::shared_ptr<SAMRAI::pdat::CellData<Real>> &&)
  -> (1880,33) std::shared_ptr<SAMRAI::pdat::CellData<Real>>::~shared_ptr(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *)
  -> INLINE: (1880,33) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (1880,33) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (1880,47) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1880,61) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (1880,61) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (1880,61) std::allocator<char>::allocator(std::allocator<char> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INDIRECT- (VIRTUAL): (1880,61)  EXPR_CONV.SI64.P64(*((SI64*) (__$Ued_V$ee7.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(18(SI32)) * 8(I64))))
  -> INLINE: (1881,29) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> DELETED: (1881,33) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (1881,33) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> (1881,33) std::shared_ptr<SAMRAI::pdat::CellData<Real>>::~shared_ptr(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *)
  -> (1881,33) std::shared_ptr<SAMRAI::pdat::CellData<Real>>::operator=(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *, std::shared_ptr<SAMRAI::pdat::CellData<Real>> &&)
  -> INLINE: (1881,47) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1881,61) std::allocator<char>::allocator(std::allocator<char> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INDIRECT- (VIRTUAL): (1881,61)  EXPR_CONV.SI64.P64(*((SI64*) (__$Uee_V$ee8.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(18(SI32)) * 8(I64))))
  -> INLINE: (1881,61) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (1881,61) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (1883,79) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (1883,82) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1883,84) SAMRAI::hier::PatchData::getGhostCellWidth(const SAMRAI::hier::PatchData *) const
  -> INLINE: (1884,83) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (1884,86) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1884,88) SAMRAI::hier::PatchData::getGhostBox(const SAMRAI::hier::PatchData *) const
  -> (1884,102) SAMRAI::hier::Box::numberCells(SAMRAI::hier::IntVector *, const SAMRAI::hier::Box *) const
  -> INLINE: (1886,79) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (1886,82) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1886,84) SAMRAI::hier::PatchData::getGhostCellWidth(const SAMRAI::hier::PatchData *) const
  -> INLINE: (1887,83) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (1887,86) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1887,88) SAMRAI::hier::PatchData::getGhostBox(const SAMRAI::hier::PatchData *) const
  -> (1887,102) SAMRAI::hier::Box::numberCells(SAMRAI::hier::IntVector *, const SAMRAI::hier::Box *) const
  -> INLINE: (1889,79) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (1889,82) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1889,84) SAMRAI::hier::PatchData::getGhostCellWidth(const SAMRAI::hier::PatchData *) const
  -> INLINE: (1890,83) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (1890,86) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1890,88) SAMRAI::hier::PatchData::getGhostBox(const SAMRAI::hier::PatchData *) const
  -> (1890,102) SAMRAI::hier::Box::numberCells(SAMRAI::hier::IntVector *, const SAMRAI::hier::Box *) const
  -> INLINE: (1892,86) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (1893,86) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (1894,86) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (1895,93) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (1896,93) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (1898,86) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (1899,86) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (1900,86) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (1901,93) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (1902,93) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (1904,86) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (1905,86) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (1906,86) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (1907,93) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (1908,93) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> (1910,28) std::vector<Real *, std::allocator<Real *>>::~vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (1910,28) std::vector<Real *, std::allocator<Real *>>::vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (1911,28) std::vector<Real *, std::allocator<Real *>>::~vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (1911,28) std::vector<Real *, std::allocator<Real *>>::vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (1912,28) std::vector<Real *, std::allocator<Real *>>::~vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (1912,28) std::vector<Real *, std::allocator<Real *>>::vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (1913,18) std::vector<Real *, std::allocator<Real *>>::reserve(std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> (1914,18) std::vector<Real *, std::allocator<Real *>>::reserve(std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> (1915,18) std::vector<Real *, std::allocator<Real *>>::reserve(std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> (1918,22) std::vector<Real *, std::allocator<Real *>>::push_back(std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::value_type &&)
  -> INLINE: (1918,52) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (1918,55) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1918,57) SAMRAI::pdat::CellData<Real>::getPointer(SAMRAI::pdat::CellData<Real> *, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,17) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,19) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> (1919,22) std::vector<Real *, std::allocator<Real *>>::push_back(std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::value_type &&)
  -> INLINE: (1919,52) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (1919,55) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1919,57) SAMRAI::pdat::CellData<Real>::getPointer(SAMRAI::pdat::CellData<Real> *, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,17) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,19) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> (1920,22) std::vector<Real *, std::allocator<Real *>>::push_back(std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::value_type &&)
  -> INLINE: (1920,52) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (1920,55) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1920,57) SAMRAI::pdat::CellData<Real>::getPointer(SAMRAI::pdat::CellData<Real> *, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,17) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,19) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (1923,27) std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1933,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1933,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (1958,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1958,73) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (1969,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (1969,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (2004,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2004,74) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2005,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2005,74) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2016,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (2016,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (2061,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2061,75) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2062,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2062,75) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2063,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2063,75) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2074,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (2074,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (2129,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2129,76) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2130,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2130,76) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2131,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2131,76) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2132,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2132,76) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2143,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (2143,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (2208,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2208,77) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2209,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2209,77) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2210,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2210,77) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2211,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2211,77) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2212,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2212,77) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2223,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (2223,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (2298,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2298,78) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2299,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2299,78) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2300,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2300,78) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2301,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2301,78) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2302,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2302,78) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2303,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2303,78) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2319,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (2319,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (2344,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2344,73) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2355,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (2355,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (2390,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2390,74) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2391,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2391,74) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2402,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (2402,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (2447,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2447,75) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2448,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2448,75) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2449,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2449,75) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2460,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (2460,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (2515,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2515,76) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2516,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2516,76) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2517,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2517,76) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2518,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2518,76) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2529,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (2529,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (2594,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2594,77) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2595,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2595,77) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2596,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2596,77) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2597,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2597,77) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2598,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2598,77) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2609,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (2609,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (2684,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2684,78) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2685,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2685,78) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2686,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2686,78) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2687,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2687,78) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2688,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2688,78) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2689,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2689,78) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2705,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (2705,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (2730,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2730,73) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2741,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (2741,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (2776,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2776,74) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2777,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2777,74) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2788,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (2788,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (2833,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2833,75) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2834,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2834,75) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2835,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2835,75) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2846,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (2846,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (2901,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2901,76) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2902,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2902,76) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2903,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2903,76) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2904,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2904,76) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2915,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (2915,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (2980,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2980,77) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2981,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2981,77) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2982,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2982,77) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2983,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2983,77) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2984,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2984,77) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (2995,49) std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::SideData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (2995,51) SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,30) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp:(162,32) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (3070,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (3070,78) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (3071,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (3071,78) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (3072,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (3072,78) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (3073,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (3073,78) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (3074,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (3074,78) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (3075,46) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (3075,78) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (3083,27) std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (3089,25) std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic> *) const
  -> DELETED: (3093,54) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INLINE: (3093,54) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (3093,77) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (3093,91) std::basic_string<char, std::char_traits<char>, std::allocator<char>>::~basic_string(std::basic_string<char, std::char_traits<char>, std::allocator<char>> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> DELETED: (3093,91) std::allocator<char>::~allocator(std::allocator<char> *)
  -> INDIRECT- (VIRTUAL): (3093,91)  EXPR_CONV.SI64.P64(*((SI64*) (__$Uf4_V$ffb.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(18(SI32)) * 8(I64))))
  -> INLINE: (3093,91) std::allocator<char>::allocator(std::allocator<char> *)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> (3093,91) std::shared_ptr<SAMRAI::pdat::CellData<Real>>::~shared_ptr(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *)
  -> INLINE: (3095,62) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (3095,64) SAMRAI::hier::PatchData::getGhostCellWidth(const SAMRAI::hier::PatchData *) const
  -> INLINE: (3096,66) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (3096,68) SAMRAI::hier::PatchData::getGhostBox(const SAMRAI::hier::PatchData *) const
  -> (3096,82) SAMRAI::hier::Box::numberCells(SAMRAI::hier::IntVector *, const SAMRAI::hier::Box *) const
  -> INLINE: (3098,72) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (3099,72) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (3100,72) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (3101,79) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (3102,79) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (3104,31) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (3104,33) SAMRAI::pdat::CellData<Real>::getPointer(SAMRAI::pdat::CellData<Real> *, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,17) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,19) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (3105,31) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (3105,33) SAMRAI::pdat::CellData<Real>::getPointer(SAMRAI::pdat::CellData<Real> *, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,17) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,19) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (3106,31) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (3106,33) SAMRAI::pdat::CellData<Real>::getPointer(SAMRAI::pdat::CellData<Real> *, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,17) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,19) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> (3108,42) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::~vector(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *)
  -> (3108,42) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::vector(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *)
  -> (3109,44) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::reserve(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *, std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::size_type)
  -> (3111,42) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::~vector(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *)
  -> (3111,42) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::vector(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *)
  -> (3112,48) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::reserve(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *, std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::size_type)
  -> INLINE: (3115,29) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> (3115,29) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::~vector(std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *)
  -> INDIRECT- (VIRTUAL): (3115,29)  EXPR_CONV.SI64.P64(*((SI64*) (__$Uf5_V$ffc.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(23(SI32)) * 8(I64))))
  -> (3117,32) std::vector<Real *, std::allocator<Real *>>::~vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (3117,32) std::vector<Real *, std::allocator<Real *>>::vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (3118,15) std::vector<Real *, std::allocator<Real *>>::reserve(std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (3122,75) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size(const std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *) const
  -> INLINE: (3122,75) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size(const std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *) const
  -> INLINE: (3124,51) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (3124,55) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (3124,57) SAMRAI::pdat::CellData<Real>::getDepth(const SAMRAI::pdat::CellData<Real> *) const
  -> (3133,23) std::vector<Real *, std::allocator<Real *>>::push_back(std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::value_type &&)
  -> INLINE: (3133,55) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (3133,59) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (3133,61) SAMRAI::pdat::CellData<Real>::getPointer(SAMRAI::pdat::CellData<Real> *, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,17) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,19) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> (3134,52) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::push_back(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *, const std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::value_type &)
  -> INLINE: (3134,84) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (3134,88) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (3134,90) SAMRAI::hier::PatchData::getGhostCellWidth(const SAMRAI::hier::PatchData *) const
  -> (3135,56) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::push_back(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *, std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::value_type &&)
  -> INLINE: (3136,47) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::operator[](std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type)
  -> INLINE: (3136,51) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (3136,53) SAMRAI::hier::PatchData::getGhostBox(const SAMRAI::hier::PatchData *) const
  -> (3136,67) SAMRAI::hier::Box::numberCells(SAMRAI::hier::IntVector *, const SAMRAI::hier::Box *) const
  -> INLINE: (3144,31) std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>>::operator[](std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>> *, std::vector<EQN_FORM::TYPE, std::allocator<EQN_FORM::TYPE>>::size_type)
  -> INLINE: (3146,37) std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::CellData<Real>, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (3146,39) SAMRAI::pdat::CellData<Real>::getPointer(SAMRAI::pdat::CellData<Real> *, int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,17) std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::pdat::ArrayData<Real>, __gnu_cxx::_S_atomic> *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp:(128,19) SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp:(210,19) std::vector<double, std::allocator<double>>::operator[](std::vector<double, std::allocator<double>> *, std::vector<double, std::allocator<double>>::size_type)
  -> INLINE: (3148,96) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::operator[](std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *, std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::size_type)
  -> INLINE: (3148,100) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (3149,96) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::operator[](std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *, std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::size_type)
  -> INLINE: (3149,100) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (3150,96) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::operator[](std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *, std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::size_type)
  -> INLINE: (3150,100) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (3151,103) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::operator[](std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *, std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::size_type)
  -> INLINE: (3151,107) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (3152,103) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::operator[](std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *, std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::size_type)
  -> INLINE: (3152,107) SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(256,22) std::vector<int, std::allocator<int>>::operator[](std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type)
  -> INLINE: (3204,69) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (3299,69) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (3427,69) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (3588,69) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (3782,69) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> INLINE: (4009,69) std::vector<Real *, std::allocator<Real *>>::operator[](std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)
  -> (4041,9) std::shared_ptr<SAMRAI::pdat::CellData<Real>>::~shared_ptr(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *)
  -> (4041,9) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::~vector(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *)
  -> (4041,9) std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::~vector(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *)
  -> (4041,9) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::~vector(std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *)
  -> (4041,9) std::vector<Real *, std::allocator<Real *>>::~vector(std::vector<Real *, std::allocator<Real *>> *)
  -> INLINE: (4043,25) std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<SAMRAI::tbox::Timer, __gnu_cxx::_S_atomic> *) const
  -> INLINE: (4049,21) std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic>::operator->(const std::__shared_ptr<FlowModel, __gnu_cxx::_S_atomic> *) const
  -> INDIRECT- (VIRTUAL): (4049,21)  EXPR_CONV.SI64.P64(*((SI64*) (__$Uef_V$ee9.0.613->__vptr_V$213_2.24 + EXPR_CONV.SI32.I64(15(SI32)) * 8(I64))))
  -> (4051,5) std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::~unordered_map(std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>> *)
  -> (4051,5) std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::~vector(std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *)
  -> (4051,5) std::vector<Real *, std::allocator<Real *>>::~vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (4051,5) std::vector<Real *, std::allocator<Real *>>::~vector(std::vector<Real *, std::allocator<Real *>> *)
  -> (4051,5) std::vector<Real *, std::allocator<Real *>>::~vector(std::vector<Real *, std::allocator<Real *>> *)


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(304,9)
   remark #15523: loop was not vectorized: loop control variable ei was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(452,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[0] (454:51) and F_face_x[i] (475:21)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(457,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i] (475:21) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (475:21)
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(419,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[0] (421:51) and F_face_x[i] (440:21)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(424,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i] (440:21) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (440:21)
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(389,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[0] (391:51) and F_face_x[i] (408:21)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(394,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i] (408:21) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (408:21)
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(362,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[0] (364:51) and F_face_x[i] (379:21)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(367,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i] (379:21) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (379:21)
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(338,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[0] (340:51) and F_face_x[i] (353:21)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(343,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i] (353:21) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (353:21)
      remark #25439: unrolled with remainder by 4  
   LOOP END

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(343,17)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(317,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[0] (319:51) and F_face_x[i] (330:21)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(322,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i] (330:21) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (330:21)
      remark #25439: unrolled with remainder by 2  
   LOOP END

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(322,17)
   <Remainder>
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(515,75)
   remark #15523: loop was not vectorized: loop control variable vi was found, but loop iteration count cannot be computed before executing the loop

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(519,17)
      remark #15333: loop was not vectorized: exception handling for a call prevents vectorization   [ /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(526,23) ]
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(669,25)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed FLOW dependence between S[i] (689:29) and u[i+1+num_subghosts_0_velocity] (689:29)
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(638,25)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed FLOW dependence between S[i] (656:29) and u[i+1+num_subghosts_0_velocity] (656:29)
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(610,25)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed FLOW dependence between S[i] (626:29) and u[i+1+num_subghosts_0_velocity] (626:29)
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(585,25)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed FLOW dependence between S[i] (599:29) and u[i+1+num_subghosts_0_velocity] (599:29)
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(563,25)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed FLOW dependence between S[i] (575:29) and u[i+1+num_subghosts_0_velocity] (575:29)
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(544,25)
<Peeled loop for vectorization, Multiversioned v1>
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(544,25)
<Multiversioned v1>
   remark #25228: Loop multiversioned for Data Dependence
   remark #15300: LOOP WAS VECTORIZED
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(544,25)
<Remainder loop for vectorization, Multiversioned v1>
   remark #15301: REMAINDER LOOP WAS VECTORIZED
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(544,25)
<Remainder loop for vectorization, Multiversioned v1>
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(544,25)
<Multiversioned v2>
   remark #15304: loop was not vectorized: non-vectorizable loop instance from multiversioning
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(771,9)
   remark #15523: loop was not vectorized: loop control variable ei was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(995,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[0] (997:51) and F_face_x[i+j*(interior_dim_0+1)] (1044:25)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(999,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)] (1044:25) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (1044:25)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1002,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)] (1044:25) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (1044:25)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(939,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[0] (941:51) and F_face_x[i+j*(interior_dim_0+1)] (982:25)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(943,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)] (982:25) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (982:25)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(946,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)] (982:25) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (982:25)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(890,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[0] (892:51) and F_face_x[i+j*(interior_dim_0+1)] (927:25)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(894,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)] (927:25) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (927:25)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(897,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)] (927:25) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (927:25)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(848,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[0] (850:51) and F_face_x[i+j*(interior_dim_0+1)] (879:25)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(852,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)] (879:25) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (879:25)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(855,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)] (879:25) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (879:25)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(813,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[0] (815:51) and F_face_x[i+j*(interior_dim_0+1)] (838:25)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(817,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)] (838:25) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (838:25)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(820,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)] (838:25) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (838:25)
         remark #25439: unrolled with remainder by 4  
      LOOP END

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(820,21)
      <Remainder>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(785,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[0] (787:51) and F_face_x[i+j*(interior_dim_0+1)] (804:25)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(789,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)] (804:25) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (804:25)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(792,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)] (804:25) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (804:25)
         remark #25439: unrolled with remainder by 2  
      LOOP END

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(792,21)
      <Remainder>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1273,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[1] (1275:51) and F_face_y[i+j*interior_dim_0] (1322:25)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1277,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0] (1322:25) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (1322:25)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1280,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0] (1322:25) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (1322:25)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1217,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[1] (1219:51) and F_face_y[i+j*interior_dim_0] (1260:25)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1221,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0] (1260:25) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (1260:25)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1224,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0] (1260:25) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (1260:25)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1168,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[1] (1170:51) and F_face_y[i+j*interior_dim_0] (1205:25)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1172,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0] (1205:25) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (1205:25)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1175,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0] (1205:25) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (1205:25)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1126,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[1] (1128:51) and F_face_y[i+j*interior_dim_0] (1157:25)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1130,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0] (1157:25) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (1157:25)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1133,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0] (1157:25) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (1157:25)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1091,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[1] (1093:51) and F_face_y[i+j*interior_dim_0] (1116:25)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1095,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0] (1116:25) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (1116:25)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1098,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0] (1116:25) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (1116:25)
         remark #25439: unrolled with remainder by 4  
      LOOP END

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1098,21)
      <Remainder>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1063,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[1] (1065:51) and F_face_y[i+j*interior_dim_0] (1082:25)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1067,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0] (1082:25) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (1082:25)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1070,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0] (1082:25) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (1082:25)
         remark #25439: unrolled with remainder by 2  
      LOOP END

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1070,21)
      <Remainder>
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1371,75)
   remark #15523: loop was not vectorized: loop control variable vi was found, but loop iteration count cannot be computed before executing the loop

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1375,17)
      remark #15333: loop was not vectorized: exception handling for a call prevents vectorization   [ /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1382,23) ]
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1723,25)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0] (1806:33) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (1806:33)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1726,29)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0] (1806:33) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (1806:33)
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1631,25)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0] (1702:33) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (1702:33)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1634,29)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0] (1702:33) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (1702:33)
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1553,25)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0] (1612:33) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (1612:33)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1556,29)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0] (1612:33) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (1612:33)
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1489,25)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0] (1536:33) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (1536:33)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1492,29)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0] (1536:33) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (1536:33)
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1439,25)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0] (1474:33) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (1474:33)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1442,29)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0] (1474:33) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (1474:33)
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1403,25)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0] (1426:33) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (1426:33)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1406,29)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0] (1426:33) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (1426:33)
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1916,9)
   remark #15523: loop was not vectorized: loop control variable ei was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2221,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[0] (2223:51) and F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2297:29)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2225,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed OUTPUT dependence between F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2297:29) and F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2297:29)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2227,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2297:29) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (2297:29)

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2230,25)
            remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
            remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2297:29) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (2297:29)
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2141,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[0] (2143:51) and F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2207:29)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2145,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed OUTPUT dependence between F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2207:29) and F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2207:29)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2147,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2207:29) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (2207:29)

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2150,25)
            remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
            remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2207:29) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (2207:29)
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2072,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[0] (2074:51) and F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2128:29)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2076,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed OUTPUT dependence between F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2128:29) and F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2128:29)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2078,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2128:29) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (2128:29)

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2081,25)
            remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
            remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2128:29) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (2128:29)
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2014,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[0] (2016:51) and F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2060:29)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2018,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed OUTPUT dependence between F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2060:29) and F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2060:29)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2020,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2060:29) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (2060:29)

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2023,25)
            remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
            remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2060:29) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (2060:29)
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1967,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[0] (1969:51) and F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2003:29)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1971,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed OUTPUT dependence between F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2003:29) and F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2003:29)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1973,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2003:29) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (2003:29)

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1976,25)
            remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
            remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (2003:29) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (2003:29)
            remark #25439: unrolled with remainder by 4  
         LOOP END

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1976,25)
         <Remainder>
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1931,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[0] (1933:51) and F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (1957:29)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1935,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed OUTPUT dependence between F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (1957:29) and F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (1957:29)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1937,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (1957:29) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (1957:29)

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1940,25)
            remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
            remark #15346: vector dependence: assumed FLOW dependence between F_face_x[i+j*(interior_dim_0+1)+(k*(interior_dim_0+1))*interior_ (1957:29) and F_node_x.F_node_x.F_node_x.F_node_x[ei][i-1+num_subghosts_0_conv (1957:29)
            remark #25439: unrolled with remainder by 2  
         LOOP END

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1940,25)
         <Remainder>
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2607,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[1] (2609:51) and F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2683:29)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2611,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed OUTPUT dependence between F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2683:29) and F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2683:29)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2613,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2683:29) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (2683:29)

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2616,25)
            remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
            remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2683:29) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (2683:29)
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2527,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[1] (2529:51) and F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2593:29)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2531,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed OUTPUT dependence between F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2593:29) and F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2593:29)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2533,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2593:29) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (2593:29)

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2536,25)
            remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
            remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2593:29) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (2593:29)
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2458,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[1] (2460:51) and F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2514:29)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2462,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed OUTPUT dependence between F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2514:29) and F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2514:29)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2464,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2514:29) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (2514:29)

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2467,25)
            remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
            remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2514:29) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (2514:29)
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2400,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[1] (2402:51) and F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2446:29)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2404,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed OUTPUT dependence between F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2446:29) and F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2446:29)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2406,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2446:29) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (2446:29)

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2409,25)
            remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
            remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2446:29) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (2446:29)
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2353,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[1] (2355:51) and F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2389:29)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2357,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed OUTPUT dependence between F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2389:29) and F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2389:29)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2359,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2389:29) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (2389:29)

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2362,25)
            remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
            remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2389:29) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (2389:29)
            remark #25439: unrolled with remainder by 4  
         LOOP END

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2362,25)
         <Remainder>
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2317,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[1] (2319:51) and F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2343:29)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2321,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed OUTPUT dependence between F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2343:29) and F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2343:29)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2323,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2343:29) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (2343:29)

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2326,25)
            remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
            remark #15346: vector dependence: assumed FLOW dependence between F_face_y[i+j*interior_dim_0+(k*interior_dim_0)*(interior_dim_1+1 (2343:29) and F_node_y.F_node_y.F_node_y.F_node_y[ei][i+num_subghosts_0_convec (2343:29)
            remark #25439: unrolled with remainder by 2  
         LOOP END

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2326,25)
         <Remainder>
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2993,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[2] (2995:51) and F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3069:29)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2997,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed OUTPUT dependence between F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3069:29) and F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3069:29)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2999,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3069:29) and F_node_z.F_node_z.F_node_z.F_node_z[ei][i+num_subghosts_0_convec (3069:29)

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3002,25)
            remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
            remark #15346: vector dependence: assumed FLOW dependence between F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3069:29) and F_node_z.F_node_z.F_node_z.F_node_z[ei][i+num_subghosts_0_convec (3069:29)
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2913,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[2] (2915:51) and F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2979:29)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2917,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed OUTPUT dependence between F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2979:29) and F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2979:29)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2919,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2979:29) and F_node_z.F_node_z.F_node_z.F_node_z[ei][i+num_subghosts_0_convec (2979:29)

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2922,25)
            remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
            remark #15346: vector dependence: assumed FLOW dependence between F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2979:29) and F_node_z.F_node_z.F_node_z.F_node_z[ei][i+num_subghosts_0_convec (2979:29)
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2844,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[2] (2846:51) and F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2900:29)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2848,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed OUTPUT dependence between F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2900:29) and F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2900:29)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2850,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2900:29) and F_node_z.F_node_z.F_node_z.F_node_z[ei][i+num_subghosts_0_convec (2900:29)

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2853,25)
            remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
            remark #15346: vector dependence: assumed FLOW dependence between F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2900:29) and F_node_z.F_node_z.F_node_z.F_node_z[ei][i+num_subghosts_0_convec (2900:29)
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2786,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[2] (2788:51) and F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2832:29)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2790,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed OUTPUT dependence between F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2832:29) and F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2832:29)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2792,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2832:29) and F_node_z.F_node_z.F_node_z.F_node_z[ei][i+num_subghosts_0_convec (2832:29)

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2795,25)
            remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
            remark #15346: vector dependence: assumed FLOW dependence between F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2832:29) and F_node_z.F_node_z.F_node_z.F_node_z[ei][i+num_subghosts_0_convec (2832:29)
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2739,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[2] (2741:51) and F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2775:29)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2743,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed OUTPUT dependence between F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2775:29) and F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2775:29)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2745,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2775:29) and F_node_z.F_node_z.F_node_z.F_node_z[ei][i+num_subghosts_0_convec (2775:29)

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2748,25)
            remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
            remark #15346: vector dependence: assumed FLOW dependence between F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2775:29) and F_node_z.F_node_z.F_node_z.F_node_z[ei][i+num_subghosts_0_convec (2775:29)
            remark #25439: unrolled with remainder by 4  
         LOOP END

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2748,25)
         <Remainder>
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2703,13)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between convective_flux.convective_flux.convective_flux->d_data[2] (2705:51) and F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2729:29)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2707,17)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed OUTPUT dependence between F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2729:29) and F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2729:29)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2709,21)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2729:29) and F_node_z.F_node_z.F_node_z.F_node_z[ei][i+num_subghosts_0_convec (2729:29)

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2712,25)
            remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
            remark #15346: vector dependence: assumed FLOW dependence between F_face_z[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (2729:29) and F_node_z.F_node_z.F_node_z.F_node_z[ei][i+num_subghosts_0_convec (2729:29)
            remark #25439: unrolled with remainder by 2  
         LOOP END

         LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(2712,25)
         <Remainder>
         LOOP END
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3122,75)
   remark #15523: loop was not vectorized: loop control variable vi was found, but loop iteration count cannot be computed before executing the loop

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3126,17)
      remark #15333: loop was not vectorized: exception handling for a call prevents vectorization   [ /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3133,23) ]
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3811,24)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed OUTPUT dependence between S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (4009:37) and S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (4009:37)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3813,29)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (4009:37) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (4009:37)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3816,33)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (4009:37) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (4009:37)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3614,25)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed OUTPUT dependence between S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3782:37) and S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3782:37)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3616,29)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3782:37) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (3782:37)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3619,33)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3782:37) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (3782:37)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3450,25)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed OUTPUT dependence between S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3588:37) and S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3588:37)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3452,29)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3588:37) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (3588:37)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3455,33)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3588:37) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (3588:37)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3319,25)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed OUTPUT dependence between S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3427:37) and S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3427:37)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3321,29)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3427:37) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (3427:37)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3324,33)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3427:37) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (3427:37)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3221,25)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed OUTPUT dependence between S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3299:37) and S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3299:37)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3223,29)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3299:37) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (3299:37)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3226,33)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3299:37) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (3299:37)
      LOOP END
   LOOP END
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3156,25)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed OUTPUT dependence between S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3204:37) and S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3204:37)

   LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3158,29)
      remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
      remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3204:37) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (3204:37)

      LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3161,33)
         remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
         remark #15346: vector dependence: assumed FLOW dependence between S[i+j*interior_dim_0+(k*interior_dim_0)*interior_dim_1] (3204:37) and u[i+1+num_subghosts_0_velocity+(j+num_subghosts_1_velocity)*subg (3204:37)
      LOOP END
   LOOP END
LOOP END


Non-optimizable loops:


LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(533,13)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(541,21) ]
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1391,13)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(1401,21) ]
LOOP END

LOOP BEGIN at /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3142,13)
   remark #15535: loop was not vectorized: loop contains switch statement. Consider using if-else statement.   [ /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(3154,21) ]
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/basic_string.h(1725,18):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
/usr/include/c++/4.8.5/bits/basic_string.h(1725,18):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (1, 0)
/home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp(137,1):remark #34051: REGISTER ALLOCATION : [_ZN34ConvectiveFluxReconstructorCentral37computeConvectiveFluxAndSourceOnPatchERN6SAMRAI4hier5PatchERKSt10shared_ptrINS0_4pdat12SideVariableIdEEERKS4_INS5_12CellVariableIdEEERKS4_INS1_15VariableContextEEddi] /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp:137

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   30[ rax rdx rcx rbx rsi rdi r8-r15 zmm0-zmm15]
        
    Routine temporaries
        Total         :    5834
            Global    :    1824
            Local     :    4010
        Regenerable   :     726
        Spilled       :     868
        
    Routine stack
        Variables     :    2854 bytes*
            Reads     :     204 [5.73e+01 ~ 0.7%]
            Writes    :     133 [3.37e+01 ~ 0.4%]
        Spills        :    6864 bytes*
            Reads     :    2101 [8.03e+02 ~ 9.9%]
            Writes    :    1136 [2.00e+02 ~ 2.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::basic_string<char, std::char_traits<char>, std::allocator<char>>::_S_construct<char *>(char *, char *, const std::allocator<char> &, std::forward_iterator_tag)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/char_traits.h(271,40):remark #34026: call to memcpy implemented as a call to optimized library version
/usr/include/c++/4.8.5/bits/basic_string.tcc(126,7):remark #34051: REGISTER ALLOCATION : [_ZNSs12_S_constructIPcEES0_T_S1_RKSaIcESt20forward_iterator_tag] /usr/include/c++/4.8.5/bits/basic_string.tcc:126

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rsi rdi r12-r15]
        
    Routine temporaries
        Total         :      30
            Global    :      13
            Local     :      17
        Regenerable   :       7
        Spilled       :       4
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: SAMRAI::hier::Box::numberCells(SAMRAI::hier::IntVector *, const SAMRAI::hier::Box *) const

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (SAMRAI::hier::Box::numberCells(SAMRAI::hier::IntVector *, const SAMRAI::hier::Box *) const) [45] /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Box.h(636,4)
  -> INLINE: (637,11) SAMRAI::hier::Box::empty(const SAMRAI::hier::Box *) const
    -> INLINE: (604,32) SAMRAI::hier::Box::getDim(const SAMRAI::hier::Box *) const
      -> INLINE: (1299,19) SAMRAI::hier::Index::getDim(const SAMRAI::hier::Index *) const
    -> INLINE: (604,32) SAMRAI::hier::Box::getDim(const SAMRAI::hier::Box *) const
      -> INLINE: (1299,19) SAMRAI::hier::Index::getDim(const SAMRAI::hier::Index *) const
    -> INLINE: (604,41) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
    -> INLINE: (604,41) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
    -> INLINE: (605,21) SAMRAI::hier::Index::operator()(const SAMRAI::hier::Index *, unsigned int) const
    -> INLINE: (605,31) SAMRAI::hier::Index::operator()(const SAMRAI::hier::Index *, unsigned int) const
  -> INLINE: (638,17) SAMRAI::hier::IntVector::getZero(const SAMRAI::tbox::Dimension &)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(1133,28) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
  -> INLINE: (638,36) SAMRAI::hier::Box::getDim(const SAMRAI::hier::Box *) const
    -> INLINE: (1299,19) SAMRAI::hier::Index::getDim(const SAMRAI::hier::Index *) const
  -> INLINE: (640,32) SAMRAI::hier::Index::operator-(SAMRAI::hier::Index *, const SAMRAI::hier::Index *, const SAMRAI::hier::Index &) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Index.h:(284,11) SAMRAI::hier::Index::operator-=(SAMRAI::hier::Index *, const SAMRAI::hier::Index &)
      -> INLINE: (267,42) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
      -> INLINE: (267,42) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
  -> INLINE: (640,39) SAMRAI::hier::Index::operator+(SAMRAI::hier::Index *, const SAMRAI::hier::Index *, int) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Index.h:(253,11) SAMRAI::hier::Index::operator+=(SAMRAI::hier::Index *, int)
      -> INLINE: (239,42) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
      -> INLINE: (239,42) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Box.h(604,41) inlined into /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Box.h(638,11)
   remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Index.h(267,42) inlined into /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Box.h(641,32)
   remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 2  
LOOP END

LOOP BEGIN at /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Index.h(239,42) inlined into /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Box.h(641,39)
   remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 8  
LOOP END

    Report from: Code generation optimizations [cg]

/home/akula/libraries/SAMRAI/include/SAMRAI/hier/Box.h(636,4):remark #34051: REGISTER ALLOCATION : [_ZNK6SAMRAI4hier3Box11numberCellsEv] /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Box.h:636

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    8[ rax rdx rcx rbx rsi rdi r8 r13]
        
    Routine temporaries
        Total         :      79
            Global    :      17
            Local     :      62
        Regenerable   :      13
        Spilled       :       2
        
    Routine stack
        Variables     :      56 bytes*
            Reads     :      13 [3.69e+00 ~ 4.7%]
            Writes    :      12 [2.25e+00 ~ 2.9%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::push_back(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *, std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::value_type &&)

    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at /usr/include/c++/4.8.5/bits/stl_uninitialized.h(74,8) inlined into /usr/include/c++/4.8.5/bits/stl_vector.h(921,9)
   remark #15523: loop was not vectorized: loop control variable __cur was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at /usr/include/c++/4.8.5/bits/stl_construct.h(102,4) inlined into /usr/include/c++/4.8.5/bits/stl_vector.h(921,9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_vector.h(920,7):remark #34051: REGISTER ALLOCATION : [_ZNSt6vectorIN6SAMRAI4hier9IntVectorESaIS2_EE9push_backEOS2_] /usr/include/c++/4.8.5/bits/stl_vector.h:920

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   13[ rax rdx rcx rbx rbp rsi rdi r8-r9 r12-r15]
        
    Routine temporaries
        Total         :     105
            Global    :      20
            Local     :      85
        Regenerable   :       7
        Spilled       :       6
        
    Routine stack
        Variables     :       8 bytes*
            Reads     :       5 [0.00e+00 ~ 0.0%]
            Writes    :       5 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: __gnu_cxx::new_allocator<SAMRAI::hier::IntVector>::destroy<SAMRAI::hier::IntVector>(__gnu_cxx::new_allocator<SAMRAI::hier::IntVector> *, SAMRAI::hier::IntVector *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/ext/new_allocator.h(124,27):remark #34051: REGISTER ALLOCATION : [_ZN9__gnu_cxx13new_allocatorIN6SAMRAI4hier9IntVectorEE7destroyIS3_EEvPT_] /usr/include/c++/4.8.5/ext/new_allocator.h:124

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rsi rdi]
        
    Routine temporaries
        Total         :      13
            Global    :       0
            Local     :      13
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::_Vector_base<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::_M_deallocate(std::_Vector_base<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *, std::_Vector_base<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::pointer, std::size_t)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_vector.h(172,7):remark #34051: REGISTER ALLOCATION : [_ZNSt12_Vector_baseIN6SAMRAI4hier9IntVectorESaIS2_EE13_M_deallocateEPS2_m] /usr/include/c++/4.8.5/bits/stl_vector.h:172

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rdx rsi rdi]
        
    Routine temporaries
        Total         :      11
            Global    :       7
            Local     :       4
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::_Destroy_aux<false>::__destroy<std::_Vector_base<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::pointer>(std::_Vector_base<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::pointer, std::_Vector_base<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::pointer)

    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at /usr/include/c++/4.8.5/bits/stl_construct.h(102,4)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_construct.h(101,2):remark #34051: REGISTER ALLOCATION : [_ZNSt12_Destroy_auxILb0EE9__destroyIPN6SAMRAI4hier9IntVectorEEEvT_S6_] /usr/include/c++/4.8.5/bits/stl_construct.h:101

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    5[ rax rsi rdi r12-r13]
        
    Routine temporaries
        Total         :      12
            Global    :       8
            Local     :       4
        Regenerable   :       0
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      16 bytes*
            Reads     :       2 [1.97e+00 ~ 3.5%]
            Writes    :       2 [1.97e+00 ~ 3.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::_Vector_base<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::_M_get_Tp_allocator(std::_Vector_base<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_vector.h(114,7):remark #34051: REGISTER ALLOCATION : [_ZNSt12_Vector_baseIN6SAMRAI4hier9IntVectorESaIS2_EE19_M_get_Tp_allocatorEv] /usr/include/c++/4.8.5/bits/stl_vector.h:114

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdi]
        
    Routine temporaries
        Total         :       9
            Global    :       0
            Local     :       9
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::size(const std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *) const

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_vector.h(646,7):remark #34051: REGISTER ALLOCATION : [_ZNKSt6vectorIN6SAMRAI4hier9IntVectorESaIS2_EE4sizeEv] /usr/include/c++/4.8.5/bits/stl_vector.h:646

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rcx rdi]
        
    Routine temporaries
        Total         :      19
            Global    :       0
            Local     :      19
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::push_back(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *, const std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::value_type &)

    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at /usr/include/c++/4.8.5/bits/stl_uninitialized.h(74,8) inlined into /usr/include/c++/4.8.5/bits/stl_vector.h(912,4)
   remark #15523: loop was not vectorized: loop control variable __cur was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at /usr/include/c++/4.8.5/bits/stl_construct.h(102,4) inlined into /usr/include/c++/4.8.5/bits/stl_vector.h(912,4)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_vector.h(902,7):remark #34051: REGISTER ALLOCATION : [_ZNSt6vectorIN6SAMRAI4hier9IntVectorESaIS2_EE9push_backERKS2_] /usr/include/c++/4.8.5/bits/stl_vector.h:902

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   13[ rax rdx rcx rbx rbp rsi rdi r8-r9 r12-r15]
        
    Routine temporaries
        Total         :     105
            Global    :      20
            Local     :      85
        Regenerable   :       7
        Spilled       :       6
        
    Routine stack
        Variables     :       8 bytes*
            Reads     :       5 [0.00e+00 ~ 0.0%]
            Writes    :       5 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::vector<Real *, std::allocator<Real *>>::push_back(std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::value_type &&)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_algobase.h(372,6):remark #34026: call to memmove implemented as a call to optimized library version
/usr/include/c++/4.8.5/bits/stl_vector.h(920,7):remark #34051: REGISTER ALLOCATION : [_ZNSt6vectorIPdSaIS0_EE9push_backEOS0_] /usr/include/c++/4.8.5/bits/stl_vector.h:920

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rbp rsi rdi r12-r15]
        
    Routine temporaries
        Total         :      35
            Global    :      17
            Local     :      18
        Regenerable   :       2
        Spilled       :       5
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::_Vector_base<Real *, std::allocator<Real *>>::_M_deallocate(std::_Vector_base<Real *, std::allocator<Real *>> *, std::_Vector_base<Real *, std::allocator<Real *>>::pointer, std::size_t)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_vector.h(172,7):remark #34051: REGISTER ALLOCATION : [_ZNSt12_Vector_baseIPdSaIS0_EE13_M_deallocateEPS0_m] /usr/include/c++/4.8.5/bits/stl_vector.h:172

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    3[ rdx rsi rdi]
        
    Routine temporaries
        Total         :      11
            Global    :       7
            Local     :       4
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::_Vector_base<Real *, std::allocator<Real *>>::_M_get_Tp_allocator(std::_Vector_base<Real *, std::allocator<Real *>> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_vector.h(114,7):remark #34051: REGISTER ALLOCATION : [_ZNSt12_Vector_baseIPdSaIS0_EE19_M_get_Tp_allocatorEv] /usr/include/c++/4.8.5/bits/stl_vector.h:114

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdi]
        
    Routine temporaries
        Total         :       9
            Global    :       0
            Local     :       9
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::vector<Real *, std::allocator<Real *>>::size(const std::vector<Real *, std::allocator<Real *>> *) const

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_vector.h(646,7):remark #34051: REGISTER ALLOCATION : [_ZNKSt6vectorIPdSaIS0_EE4sizeEv] /usr/include/c++/4.8.5/bits/stl_vector.h:646

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdi]
        
    Routine temporaries
        Total         :      12
            Global    :       0
            Local     :      12
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::shared_ptr<SAMRAI::hier::Variable>::~shared_ptr(std::shared_ptr<SAMRAI::hier::Variable> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/shared_ptr.h(93,11):remark #34051: REGISTER ALLOCATION : [_ZNSt10shared_ptrIN6SAMRAI4hier8VariableEED1Ev] /usr/include/c++/4.8.5/bits/shared_ptr.h:93

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rcx rdi r12-r13]
        
    Routine temporaries
        Total         :      24
            Global    :      12
            Local     :      12
        Regenerable   :       3
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::insert<std::pair<std::string, SAMRAI::hier::IntVector>, void>(std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>> *, std::pair<std::string, SAMRAI::hier::IntVector> &&)

    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at /usr/include/c++/4.8.5/bits/hashtable.h(1163,15) inlined into /usr/include/c++/4.8.5/bits/unordered_map.h(371,30)
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

LOOP BEGIN at /usr/include/c++/4.8.5/bits/hashtable.h(1705,7) inlined into /usr/include/c++/4.8.5/bits/unordered_map.h(371,30)
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
   remark #25478: While Loop Unrolled by 2  
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/char_traits.h(255,16):remark #34026: call to memcmp implemented as a call to optimized library version
/usr/include/c++/4.8.5/bits/hashtable.h(780,7):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/c++/4.8.5/bits/hashtable_policy.h(769,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
/usr/include/c++/4.8.5/bits/hashtable_policy.h(769,43):remark #34000: call to memcpy implemented inline with loads and stores with proven source (alignment, offset): (16, 0), and destination (alignment, offset): (16, 0)
/usr/include/c++/4.8.5/bits/unordered_map.h(370,9):remark #34051: REGISTER ALLOCATION : [_ZNSt13unordered_mapISsN6SAMRAI4hier9IntVectorESt4hashISsESt8equal_toISsESaISt4pairIKSsS2_EEE6insertIS7_ISsS2_EvEES7_INSt8__detail14_Node_iteratorIS9_Lb0ELb1EEEbEOT_] /usr/include/c++/4.8.5/bits/unordered_map.h:370

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   17[ rax rdx rcx rbx rbp rsi rdi r8-r15 zmm0-zmm1]
        
    Routine temporaries
        Total         :     202
            Global    :      52
            Local     :     150
        Regenerable   :      23
        Spilled       :       8
        
    Routine stack
        Variables     :      74 bytes*
            Reads     :      15 [3.14e+00 ~ 2.7%]
            Writes    :      16 [3.24e+00 ~ 2.8%]
        Spills        :      16 bytes*
            Reads     :       4 [1.34e+00 ~ 1.1%]
            Writes    :       2 [1.90e+00 ~ 1.6%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::pair<std::string, SAMRAI::hier::IntVector>::~pair(std::pair<std::string, SAMRAI::hier::IntVector> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_pair.h(96,12):remark #34051: REGISTER ALLOCATION : [_ZNSt4pairISsN6SAMRAI4hier9IntVectorEED1Ev] /usr/include/c++/4.8.5/bits/stl_pair.h:96

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rcx rsi rdi r13]
        
    Routine temporaries
        Total         :      21
            Global    :      11
            Local     :      10
        Regenerable   :       5
        Spilled       :       1
        
    Routine stack
        Variables     :       1 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: __gnu_cxx::__exchange_and_add_dispatch(_Atomic_word *, int)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/ext/atomicity.h(79,3):remark #34051: REGISTER ALLOCATION : [_ZN17_INTERNALbcacec509__gnu_cxx27__exchange_and_add_dispatchEPii] /usr/include/c++/4.8.5/ext/atomicity.h:79

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rsi rdi]
        
    Routine temporaries
        Total         :      16
            Global    :       8
            Local     :       8
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::shared_ptr<SAMRAI::pdat::CellData<Real>>::~shared_ptr(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/shared_ptr.h(93,11):remark #34051: REGISTER ALLOCATION : [_ZNSt10shared_ptrIN6SAMRAI4pdat8CellDataIdEEED1Ev] /usr/include/c++/4.8.5/bits/shared_ptr.h:93

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rcx rdi r12-r13]
        
    Routine temporaries
        Total         :      24
            Global    :      12
            Local     :      12
        Regenerable   :       3
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::shared_ptr<SAMRAI::pdat::CellData<Real>>::operator=(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *, std::shared_ptr<SAMRAI::pdat::CellData<Real>> &&)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/shared_ptr_base.h(789,7):remark #34000: call to memset implemented inline with stores with proven (alignment, offset): (32, 8)
/usr/include/c++/4.8.5/bits/shared_ptr.h(290,7):remark #34051: REGISTER ALLOCATION : [_ZNSt10shared_ptrIN6SAMRAI4pdat8CellDataIdEEEaSEOS4_] /usr/include/c++/4.8.5/bits/shared_ptr.h:290

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    8[ rax rdx rcx rsi rdi r13-r15]
        
    Routine temporaries
        Total         :      30
            Global    :      15
            Local     :      15
        Regenerable   :       3
        Spilled       :       3
        
    Routine stack
        Variables     :      16 bytes*
            Reads     :       2 [2.00e+00 ~ 4.7%]
            Writes    :       4 [3.35e+00 ~ 7.9%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::pair<std::string, SAMRAI::hier::IntVector>::pair<const char (&)[9], SAMRAI::hier::IntVector &, void>(std::pair<std::string, SAMRAI::hier::IntVector> *, const char (&)[9], SAMRAI::hier::IntVector &)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_pair.h(145,66):remark #34051: REGISTER ALLOCATION : [_ZNSt4pairISsN6SAMRAI4hier9IntVectorEEC1IRA9_KcRS2_vEEOT_OT0_] /usr/include/c++/4.8.5/bits/stl_pair.h:145

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rbp rsi rdi r14]
        
    Routine temporaries
        Total         :      42
            Global    :      12
            Local     :      30
        Regenerable   :       6
        Spilled       :       2
        
    Routine stack
        Variables     :      10 bytes*
            Reads     :       2 [0.00e+00 ~ 0.0%]
            Writes    :       2 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::pair<std::string, SAMRAI::hier::IntVector>::pair<const char (&)[18], SAMRAI::hier::IntVector &, void>(std::pair<std::string, SAMRAI::hier::IntVector> *, const char (&)[18], SAMRAI::hier::IntVector &)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_pair.h(145,66):remark #34051: REGISTER ALLOCATION : [_ZNSt4pairISsN6SAMRAI4hier9IntVectorEEC1IRA18_KcRS2_vEEOT_OT0_] /usr/include/c++/4.8.5/bits/stl_pair.h:145

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rbp rsi rdi r14]
        
    Routine temporaries
        Total         :      42
            Global    :      12
            Local     :      30
        Regenerable   :       6
        Spilled       :       2
        
    Routine stack
        Variables     :      10 bytes*
            Reads     :       2 [0.00e+00 ~ 0.0%]
            Writes    :       2 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::~unordered_map(std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>> *)

    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at /usr/include/c++/4.8.5/bits/hashtable.h(759,7) inlined into /usr/include/c++/4.8.5/bits/unordered_map.h(98,11)
   remark #15521: loop was not vectorized: loop control variable was not identified. Explicitly compute the iteration count before executing the loop or try using canonical loop form from OpenMP specification
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/hashtable.h(1642,7):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/c++/4.8.5/bits/unordered_map.h(97,11):remark #34051: REGISTER ALLOCATION : [_ZNSt13unordered_mapISsN6SAMRAI4hier9IntVectorESt4hashISsESt8equal_toISsESaISt4pairIKSsS2_EEED1Ev] /usr/include/c++/4.8.5/bits/unordered_map.h:97

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   10[ rax rdx rcx rbx rbp rsi rdi r8 r14-r15]
        
    Routine temporaries
        Total         :      33
            Global    :      13
            Local     :      20
        Regenerable   :       7
        Spilled       :       4
        
    Routine stack
        Variables     :       1 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      24 bytes*
            Reads     :       3 [2.33e+00 ~ 2.5%]
            Writes    :       3 [2.33e+00 ~ 2.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::vector(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_vector.h(249,17):remark #34051: REGISTER ALLOCATION : [_ZNSt6vectorIN6SAMRAI4hier9IntVectorESaIS2_EEC1Ev] /usr/include/c++/4.8.5/bits/stl_vector.h:249

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdi]
        
    Routine temporaries
        Total         :       9
            Global    :       0
            Local     :       9
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::reserve(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *, std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::size_type)

    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at /usr/include/c++/4.8.5/bits/stl_uninitialized.h(74,8) inlined into /usr/include/c++/4.8.5/bits/vector.tcc(74,20)
   remark #15523: loop was not vectorized: loop control variable __cur was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at /usr/include/c++/4.8.5/bits/stl_construct.h(102,4) inlined into /usr/include/c++/4.8.5/bits/vector.tcc(77,4)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/vector.tcc(67,5):remark #34051: REGISTER ALLOCATION : [_ZNSt6vectorIN6SAMRAI4hier9IntVectorESaIS2_EE7reserveEm] /usr/include/c++/4.8.5/bits/vector.tcc:67

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   12[ rax rdx rcx rbx rbp rsi rdi r8 r12-r15]
        
    Routine temporaries
        Total         :      76
            Global    :      18
            Local     :      58
        Regenerable   :       6
        Spilled       :       8
        
    Routine stack
        Variables     :       8 bytes*
            Reads     :       3 [0.00e+00 ~ 0.0%]
            Writes    :       3 [0.00e+00 ~ 0.0%]
        Spills        :      24 bytes*
            Reads     :       7 [1.97e-01 ~ 0.4%]
            Writes    :       5 [1.97e-01 ~ 0.4%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::vector<Real *, std::allocator<Real *>>::vector(std::vector<Real *, std::allocator<Real *>> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_vector.h(249,17):remark #34051: REGISTER ALLOCATION : [_ZNSt6vectorIPdSaIS0_EEC1Ev] /usr/include/c++/4.8.5/bits/stl_vector.h:249

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdi]
        
    Routine temporaries
        Total         :       9
            Global    :       0
            Local     :       9
        Regenerable   :       1
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::vector<Real *, std::allocator<Real *>>::reserve(std::vector<Real *, std::allocator<Real *>> *, std::vector<Real *, std::allocator<Real *>>::size_type)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_algobase.h(372,6):remark #34026: call to memmove implemented as a call to optimized library version
/usr/include/c++/4.8.5/bits/vector.tcc(67,5):remark #34051: REGISTER ALLOCATION : [_ZNSt6vectorIPdSaIS0_EE7reserveEm] /usr/include/c++/4.8.5/bits/vector.tcc:67

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   11[ rax rdx rcx rbx rbp rsi rdi r12-r15]
        
    Routine temporaries
        Total         :      34
            Global    :      18
            Local     :      16
        Regenerable   :       3
        Spilled       :       6
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::vector<Real *, std::allocator<Real *>>::~vector(std::vector<Real *, std::allocator<Real *>> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_vector.h(415,7):remark #34051: REGISTER ALLOCATION : [_ZNSt6vectorIPdSaIS0_EED1Ev] /usr/include/c++/4.8.5/bits/stl_vector.h:415

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    1[ rdi]
        
    Routine temporaries
        Total         :      10
            Global    :       7
            Local     :       3
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::_Vector_base<Real *, std::allocator<Real *>>::~_Vector_base(std::_Vector_base<Real *, std::allocator<Real *>> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_vector.h(160,7):remark #34051: REGISTER ALLOCATION : [_ZNSt12_Vector_baseIPdSaIS0_EED1Ev] /usr/include/c++/4.8.5/bits/stl_vector.h:160

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    1[ rdi]
        
    Routine temporaries
        Total         :      10
            Global    :       7
            Local     :       3
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::~vector(std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *)

    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at /usr/include/c++/4.8.5/bits/stl_construct.h(102,4) inlined into /usr/include/c++/4.8.5/bits/stl_vector.h(416,9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between __first->_M_refcount->_M_pi (545:2) and *__mem (68:6)
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_vector.h(415,7):remark #34051: REGISTER ALLOCATION : [_ZNSt6vectorISt10shared_ptrIN6SAMRAI4pdat8CellDataIdEEESaIS5_EED1Ev] /usr/include/c++/4.8.5/bits/stl_vector.h:415

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :   10[ rax rdx rcx rbx rbp rsi rdi r13-r15]
        
    Routine temporaries
        Total         :      25
            Global    :      13
            Local     :      12
        Regenerable   :       3
        Spilled       :       5
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      40 bytes*
            Reads     :       5 [4.93e+00 ~ 4.5%]
            Writes    :       5 [4.93e+00 ~ 4.5%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::_Vector_base<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::~_Vector_base(std::_Vector_base<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_vector.h(160,7):remark #34051: REGISTER ALLOCATION : [_ZNSt12_Vector_baseISt10shared_ptrIN6SAMRAI4pdat8CellDataIdEEESaIS5_EED1Ev] /usr/include/c++/4.8.5/bits/stl_vector.h:160

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    1[ rdi]
        
    Routine temporaries
        Total         :      10
            Global    :       7
            Local     :       3
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::~vector(std::vector<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *)

    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at /usr/include/c++/4.8.5/bits/stl_construct.h(102,4) inlined into /usr/include/c++/4.8.5/bits/stl_vector.h(416,9)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_vector.h(415,7):remark #34051: REGISTER ALLOCATION : [_ZNSt6vectorIN6SAMRAI4hier9IntVectorESaIS2_EED1Ev] /usr/include/c++/4.8.5/bits/stl_vector.h:415

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    7[ rax rdx rcx rbx rbp rdi r15]
        
    Routine temporaries
        Total         :      13
            Global    :       9
            Local     :       4
        Regenerable   :       0
        Spilled       :       3
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      24 bytes*
            Reads     :       3 [2.96e+00 ~ 4.4%]
            Writes    :       3 [2.96e+00 ~ 4.4%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::_Vector_base<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>>::~_Vector_base(std::_Vector_base<SAMRAI::hier::IntVector, std::allocator<SAMRAI::hier::IntVector>> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_vector.h(160,7):remark #34051: REGISTER ALLOCATION : [_ZNSt12_Vector_baseIN6SAMRAI4hier9IntVectorESaIS2_EED1Ev] /usr/include/c++/4.8.5/bits/stl_vector.h:160

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    1[ rdi]
        
    Routine temporaries
        Total         :      10
            Global    :       7
            Local     :       3
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::shared_ptr<SAMRAI::pdat::SideData<Real>>::~shared_ptr(std::shared_ptr<SAMRAI::pdat::SideData<Real>> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/shared_ptr.h(93,11):remark #34051: REGISTER ALLOCATION : [_ZNSt10shared_ptrIN6SAMRAI4pdat8SideDataIdEEED1Ev] /usr/include/c++/4.8.5/bits/shared_ptr.h:93

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rcx rdi r12-r13]
        
    Routine temporaries
        Total         :      24
            Global    :      12
            Local     :      12
        Regenerable   :       3
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::shared_ptr<SAMRAI::geom::CartesianPatchGeometry>::~shared_ptr(std::shared_ptr<SAMRAI::geom::CartesianPatchGeometry> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/shared_ptr.h(93,11):remark #34051: REGISTER ALLOCATION : [_ZNSt10shared_ptrIN6SAMRAI4geom22CartesianPatchGeometryEED1Ev] /usr/include/c++/4.8.5/bits/shared_ptr.h:93

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rcx rdi r12-r13]
        
    Routine temporaries
        Total         :      24
            Global    :      12
            Local     :      12
        Regenerable   :       3
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::vector(std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>> *, std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::size_type, const std::vector<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::allocator_type &)

    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at /usr/include/c++/4.8.5/bits/stl_uninitialized.h(494,8) inlined into /usr/include/c++/4.8.5/bits/stl_vector.h(272,9)
   remark #15527: loop was not vectorized: function call to ?1memset cannot be vectorized   [ /usr/include/c++/4.8.5/bits/shared_ptr_base.h(733,17) ]
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/shared_ptr_base.h(733,17):remark #34000: call to memset implemented inline with stores with proven (alignment, offset): (1, 0)
/usr/include/c++/4.8.5/bits/stl_vector.h(271,7):remark #34051: REGISTER ALLOCATION : [_ZNSt6vectorISt10shared_ptrIN6SAMRAI4pdat8CellDataIdEEESaIS5_EEC1EmRKS6_] /usr/include/c++/4.8.5/bits/stl_vector.h:271

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    8[ rax rdx rbx rbp rsi rdi r14-r15]
        
    Routine temporaries
        Total         :      18
            Global    :      13
            Local     :       5
        Regenerable   :       2
        Spilled       :       4
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>::allocator(std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/allocator.h(113,27):remark #34051: REGISTER ALLOCATION : [_ZNSaISt10shared_ptrIN6SAMRAI4pdat8CellDataIdEEEEC1Ev] /usr/include/c++/4.8.5/bits/allocator.h:113

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    1[ rdi]
        
    Routine temporaries
        Total         :       7
            Global    :       0
            Local     :       7
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::unordered_map(std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>> *, std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::size_type, const std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::hasher &, const std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::key_equal &, const std::unordered_map<std::string, SAMRAI::hier::IntVector, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>>::allocator_type &)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/hashtable.h(780,7):remark #34026: call to memset implemented as a call to optimized library version
/usr/include/c++/4.8.5/bits/unordered_map.h(143,7):remark #34051: REGISTER ALLOCATION : [_ZNSt13unordered_mapISsN6SAMRAI4hier9IntVectorESt4hashISsESt8equal_toISsESaISt4pairIKSsS2_EEEC1EmRKS4_RKS6_RKSA_] /usr/include/c++/4.8.5/bits/unordered_map.h:143

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rsi rdi r8 r13-r15]
        
    Routine temporaries
        Total         :      27
            Global    :      12
            Local     :      15
        Regenerable   :       3
        Spilled       :       3
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>::allocator(std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/allocator.h(113,27):remark #34051: REGISTER ALLOCATION : [_ZNSaISt4pairIKSsN6SAMRAI4hier9IntVectorEEEC1Ev] /usr/include/c++/4.8.5/bits/allocator.h:113

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    1[ rdi]
        
    Routine temporaries
        Total         :       7
            Global    :       0
            Local     :       7
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::basic_stringbuf<char, std::char_traits<char>, std::allocator<char>>::~basic_stringbuf(std::basic_stringbuf<char, std::char_traits<char>, std::allocator<char>> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/iosfwd(93,11):remark #34051: REGISTER ALLOCATION : [_ZNSt15basic_stringbufIcSt11char_traitsIcESaIcEED1Ev] /usr/include/c++/4.8.5/iosfwd:93

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rcx rbp rsi rdi]
        
    Routine temporaries
        Total         :      21
            Global    :      11
            Local     :      10
        Regenerable   :       5
        Spilled       :       1
        
    Routine stack
        Variables     :       1 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: SAMRAI::hier::Box::grow(SAMRAI::hier::Box *, const SAMRAI::hier::IntVector &)

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (SAMRAI::hier::Box::grow(SAMRAI::hier::Box *, const SAMRAI::hier::IntVector &)) [99] /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Box.h(901,4)
  -> INLINE: (903,12) SAMRAI::hier::Box::empty(const SAMRAI::hier::Box *) const
    -> INLINE: (604,32) SAMRAI::hier::Box::getDim(const SAMRAI::hier::Box *) const
      -> INLINE: (1299,19) SAMRAI::hier::Index::getDim(const SAMRAI::hier::Index *) const
    -> INLINE: (604,32) SAMRAI::hier::Box::getDim(const SAMRAI::hier::Box *) const
      -> INLINE: (1299,19) SAMRAI::hier::Index::getDim(const SAMRAI::hier::Index *) const
    -> INLINE: (604,41) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
    -> INLINE: (604,41) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
    -> INLINE: (605,21) SAMRAI::hier::Index::operator()(const SAMRAI::hier::Index *, unsigned int) const
    -> INLINE: (605,31) SAMRAI::hier::Index::operator()(const SAMRAI::hier::Index *, unsigned int) const
  -> INLINE: (904,21) SAMRAI::hier::IntVector::getNumBlocks(const SAMRAI::hier::IntVector *) const
  -> INLINE: (905,45) SAMRAI::hier::BlockId::getBlockValue(const SAMRAI::hier::BlockId *) const
  -> INLINE: (906,42) SAMRAI::hier::Box::getDim(const SAMRAI::hier::Box *) const
    -> INLINE: (1299,19) SAMRAI::hier::Index::getDim(const SAMRAI::hier::Index *) const
  -> INLINE: (906,42) SAMRAI::hier::Box::getDim(const SAMRAI::hier::Box *) const
    -> INLINE: (1299,19) SAMRAI::hier::Index::getDim(const SAMRAI::hier::Index *) const
  -> INLINE: (906,51) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
  -> INLINE: (906,51) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
  -> INLINE: (907,20) SAMRAI::hier::Index::operator()(SAMRAI::hier::Index *, unsigned int)
  -> INLINE: (907,33) SAMRAI::hier::IntVector::operator()(const SAMRAI::hier::IntVector *, SAMRAI::hier::BlockId::block_t, unsigned int) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(343,22) std::vector<int, std::allocator<int>>::operator[](const std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(343,31) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
  -> INLINE: (908,20) SAMRAI::hier::Index::operator()(SAMRAI::hier::Index *, unsigned int)
  -> INLINE: (908,33) SAMRAI::hier::IntVector::operator()(const SAMRAI::hier::IntVector *, SAMRAI::hier::BlockId::block_t, unsigned int) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(343,22) std::vector<int, std::allocator<int>>::operator[](const std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(343,31) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
  -> INLINE: (911,18) SAMRAI::hier::Index::operator-=(SAMRAI::hier::Index *, const SAMRAI::hier::IntVector &)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Index.h:(300,42) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Index.h:(300,42) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Index.h:(301,27) SAMRAI::hier::IntVector::operator[](const SAMRAI::hier::IntVector *, unsigned int) const
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(272,22) std::vector<int, std::allocator<int>>::operator[](const std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type) const
  -> INLINE: (912,18) SAMRAI::hier::Index::operator+=(SAMRAI::hier::Index *, const SAMRAI::hier::IntVector &)
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Index.h:(178,42) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Index.h:(178,42) SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const
    -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Index.h:(179,27) SAMRAI::hier::IntVector::operator[](const SAMRAI::hier::IntVector *, unsigned int) const
      -> INLINE: /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h:(272,22) std::vector<int, std::allocator<int>>::operator[](const std::vector<int, std::allocator<int>> *, std::vector<int, std::allocator<int>>::size_type) const


    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Box.h(604,41) inlined into /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Box.h(904,12)
   remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
LOOP END

LOOP BEGIN at /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Box.h(906,51)
   remark #15523: loop was not vectorized: loop control variable i was found, but loop iteration count cannot be computed before executing the loop
   remark #25478: While Loop Unrolled by 8  
LOOP END

LOOP BEGIN at /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Index.h(300,42) inlined into /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Box.h(912,18)
   remark #15315: loop was not vectorized: estimated number of iterations (3) is insufficient for vectorization
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Index.h(300,42) inlined into /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Box.h(912,18)
<Remainder>
LOOP END

LOOP BEGIN at /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Index.h(178,42) inlined into /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Box.h(913,18)
   remark #15315: loop was not vectorized: estimated number of iterations (3) is insufficient for vectorization
   remark #25439: unrolled with remainder by 2  
LOOP END

LOOP BEGIN at /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Index.h(178,42) inlined into /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Box.h(913,18)
<Remainder>
LOOP END

    Report from: Code generation optimizations [cg]

/home/akula/libraries/SAMRAI/include/SAMRAI/hier/Box.h(901,4):remark #34051: REGISTER ALLOCATION : [_ZN6SAMRAI4hier3Box4growERKNS0_9IntVectorE] /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Box.h:901

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rsi rdi r8-r11]
        
    Routine temporaries
        Total         :     101
            Global    :      25
            Local     :      76
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::static_pointer_cast<SAMRAI::pdat::CellData<Real>, SAMRAI::hier::PatchData>(std::shared_ptr<SAMRAI::pdat::CellData<Real>> *, const std::shared_ptr<SAMRAI::hier::PatchData> &)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/shared_ptr.h(438,5):remark #34051: REGISTER ALLOCATION : [_ZSt19static_pointer_castIN6SAMRAI4pdat8CellDataIdEENS0_4hier9PatchDataEESt10shared_ptrIT_ERKS6_IT0_E] /usr/include/c++/4.8.5/bits/shared_ptr.h:438

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rsi rdi]
        
    Routine temporaries
        Total         :      15
            Global    :       8
            Local     :       7
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::shared_ptr<SAMRAI::hier::Variable>::shared_ptr<SAMRAI::pdat::CellVariable<Real>, void>(std::shared_ptr<SAMRAI::hier::Variable> *, const std::shared_ptr<SAMRAI::pdat::CellVariable<Real>> &)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/shared_ptr.h(219,34):remark #34051: REGISTER ALLOCATION : [_ZNSt10shared_ptrIN6SAMRAI4hier8VariableEEC1INS0_4pdat12CellVariableIdEEvEERKS_IT_E] /usr/include/c++/4.8.5/bits/shared_ptr.h:219

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rsi rdi]
        
    Routine temporaries
        Total         :      15
            Global    :       8
            Local     :       7
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::shared_ptr<SAMRAI::hier::PatchData>::~shared_ptr(std::shared_ptr<SAMRAI::hier::PatchData> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/shared_ptr.h(93,11):remark #34051: REGISTER ALLOCATION : [_ZNSt10shared_ptrIN6SAMRAI4hier9PatchDataEED1Ev] /usr/include/c++/4.8.5/bits/shared_ptr.h:93

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rcx rdi r12-r13]
        
    Routine temporaries
        Total         :      24
            Global    :      12
            Local     :      12
        Regenerable   :       3
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::static_pointer_cast<SAMRAI::pdat::SideData<Real>, SAMRAI::hier::PatchData>(std::shared_ptr<SAMRAI::pdat::SideData<Real>> *, const std::shared_ptr<SAMRAI::hier::PatchData> &)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/shared_ptr.h(438,5):remark #34051: REGISTER ALLOCATION : [_ZSt19static_pointer_castIN6SAMRAI4pdat8SideDataIdEENS0_4hier9PatchDataEESt10shared_ptrIT_ERKS6_IT0_E] /usr/include/c++/4.8.5/bits/shared_ptr.h:438

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rsi rdi]
        
    Routine temporaries
        Total         :      15
            Global    :       8
            Local     :       7
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: SAMRAI::hier::Patch::getPatchData(std::shared_ptr<SAMRAI::hier::PatchData> *, const SAMRAI::hier::Patch *, const std::shared_ptr<SAMRAI::hier::Variable> &, const std::shared_ptr<SAMRAI::hier::VariableContext> &) const

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (SAMRAI::hier::Patch::getPatchData(std::shared_ptr<SAMRAI::hier::PatchData> *, const SAMRAI::hier::Patch *, const std::shared_ptr<SAMRAI::hier::Variable> &, const std::shared_ptr<SAMRAI::hier::VariableContext> &) const) [104] /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Patch.h(185,4)
  -> INDIRECT- (VIRTUAL): (188,49)  EXPR_CONV.SI64.P64(*((SI64*) (__$U70_V$b07.0.479->__vptr_V$b09 + EXPR_CONV.SI32.I64(15(SI32)) * 8(I64))))
  -> INLINE: (190,26) std::shared_ptr<SAMRAI::hier::PatchData>::shared_ptr(std::shared_ptr<SAMRAI::hier::PatchData> *, const std::shared_ptr<SAMRAI::hier::PatchData> &)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: (190,26) std::vector<std::shared_ptr<SAMRAI::hier::PatchData>, std::allocator<std::shared_ptr<SAMRAI::hier::PatchData>>>::operator[](const std::vector<std::shared_ptr<SAMRAI::hier::PatchData>, std::allocator<std::shared_ptr<SAMRAI::hier::PatchData>>> *, std::vector<std::shared_ptr<SAMRAI::hier::PatchData>, std::allocator<std::shared_ptr<SAMRAI::hier::PatchData>>>::size_type) const


    Report from: Code generation optimizations [cg]

/home/akula/libraries/SAMRAI/include/SAMRAI/hier/Patch.h(185,4):remark #34051: REGISTER ALLOCATION : [_ZNK6SAMRAI4hier5Patch12getPatchDataERKSt10shared_ptrINS0_8VariableEERKS2_INS0_15VariableContextEE] /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Patch.h:185

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    9[ rax rdx rcx rbx rbp rsi rdi r12 r15]
        
    Routine temporaries
        Total         :      30
            Global    :      16
            Local     :      14
        Regenerable   :       2
        Spilled       :       4
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::shared_ptr<SAMRAI::hier::Variable>::shared_ptr<SAMRAI::pdat::SideVariable<Real>, void>(std::shared_ptr<SAMRAI::hier::Variable> *, const std::shared_ptr<SAMRAI::pdat::SideVariable<Real>> &)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/shared_ptr.h(219,34):remark #34051: REGISTER ALLOCATION : [_ZNSt10shared_ptrIN6SAMRAI4hier8VariableEEC1INS0_4pdat12SideVariableIdEEvEERKS_IT_E] /usr/include/c++/4.8.5/bits/shared_ptr.h:219

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rsi rdi]
        
    Routine temporaries
        Total         :      15
            Global    :       8
            Local     :       7
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::shared_ptr<SAMRAI::hier::PatchGeometry>::~shared_ptr(std::shared_ptr<SAMRAI::hier::PatchGeometry> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/shared_ptr.h(93,11):remark #34051: REGISTER ALLOCATION : [_ZNSt10shared_ptrIN6SAMRAI4hier13PatchGeometryEED1Ev] /usr/include/c++/4.8.5/bits/shared_ptr.h:93

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rcx rdi r12-r13]
        
    Routine temporaries
        Total         :      24
            Global    :      12
            Local     :      12
        Regenerable   :       3
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::static_pointer_cast<SAMRAI::geom::CartesianPatchGeometry, SAMRAI::hier::PatchGeometry>(std::shared_ptr<SAMRAI::geom::CartesianPatchGeometry> *, const std::shared_ptr<SAMRAI::hier::PatchGeometry> &)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/shared_ptr.h(438,5):remark #34051: REGISTER ALLOCATION : [_ZSt19static_pointer_castIN6SAMRAI4geom22CartesianPatchGeometryENS0_4hier13PatchGeometryEESt10shared_ptrIT_ERKS5_IT0_E] /usr/include/c++/4.8.5/bits/shared_ptr.h:438

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rsi rdi]
        
    Routine temporaries
        Total         :      15
            Global    :       8
            Local     :       7
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: SAMRAI::hier::Patch::getPatchGeometry(std::shared_ptr<SAMRAI::hier::PatchGeometry> *, const SAMRAI::hier::Patch *) const

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (SAMRAI::hier::Patch::getPatchGeometry(std::shared_ptr<SAMRAI::hier::PatchGeometry> *, const SAMRAI::hier::Patch *) const) [108] /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Patch.h(345,4)
  -> INLINE: (346,14) std::shared_ptr<SAMRAI::hier::PatchGeometry>::shared_ptr(std::shared_ptr<SAMRAI::hier::PatchGeometry> *, const std::shared_ptr<SAMRAI::hier::PatchGeometry> &)
     {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}


    Report from: Code generation optimizations [cg]

/home/akula/libraries/SAMRAI/include/SAMRAI/hier/Patch.h(345,4):remark #34051: REGISTER ALLOCATION : [_ZNK6SAMRAI4hier5Patch16getPatchGeometryEv] /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Patch.h:345

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rax rdx rsi rdi]
        
    Routine temporaries
        Total         :      15
            Global    :       8
            Local     :       7
        Regenerable   :       2
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::shared_ptr<SAMRAI::tbox::Timer>::~shared_ptr(std::shared_ptr<SAMRAI::tbox::Timer> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/shared_ptr.h(93,11):remark #34051: REGISTER ALLOCATION : [_ZNSt10shared_ptrIN6SAMRAI4tbox5TimerEED1Ev] /usr/include/c++/4.8.5/bits/shared_ptr.h:93

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rcx rdi r12-r13]
        
    Routine temporaries
        Total         :      24
            Global    :      12
            Local     :      12
        Regenerable   :       3
        Spilled       :       2
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::_Destroy_aux<false>::__destroy<std::_Vector_base<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::pointer>(std::_Vector_base<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::pointer, std::_Vector_base<std::shared_ptr<SAMRAI::pdat::CellData<Real>>, std::allocator<std::shared_ptr<SAMRAI::pdat::CellData<Real>>>>::pointer)

    Report from: Loop nest, Vector & Auto-parallelization optimizations [loop, vec, par]


LOOP BEGIN at /usr/include/c++/4.8.5/bits/stl_construct.h(102,4)
   remark #15344: loop was not vectorized: vector dependence prevents vectorization. First dependence is shown below. Use level 5 report for details
   remark #15346: vector dependence: assumed ANTI dependence between __first->_M_refcount->_M_pi (545:2) and *__mem (68:6)
LOOP END

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/stl_construct.h(101,2):remark #34051: REGISTER ALLOCATION : [_ZNSt12_Destroy_auxILb0EE9__destroyIPSt10shared_ptrIN6SAMRAI4pdat8CellDataIdEEEEEvT_S9_] /usr/include/c++/4.8.5/bits/stl_construct.h:101

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    8[ rax rdx rsi rdi r12-r15]
        
    Routine temporaries
        Total         :      24
            Global    :      12
            Local     :      12
        Regenerable   :       3
        Spilled       :       4
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :      32 bytes*
            Reads     :       4 [3.94e+00 ~ 4.0%]
            Writes    :       4 [3.94e+00 ~ 4.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: SAMRAI::tbox::Dimension::operator==(const SAMRAI::tbox::Dimension *, const SAMRAI::tbox::Dimension &) const

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::tbox::Dimension::operator==(const SAMRAI::tbox::Dimension *, const SAMRAI::tbox::Dimension &) const) /home/akula/libraries/SAMRAI/include/SAMRAI/tbox/Dimension.h(73,4)

===========================================================================

Begin optimization report for: SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::tbox::Dimension::getValue(const SAMRAI::tbox::Dimension *) const) /home/akula/libraries/SAMRAI/include/SAMRAI/tbox/Dimension.h(137,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::BlockId::getBlockValue(const SAMRAI::hier::BlockId *) const

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::BlockId::getBlockValue(const SAMRAI::hier::BlockId *) const) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/BlockId.h(119,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::IntVector::operator=(SAMRAI::hier::IntVector *, const SAMRAI::hier::IntVector &)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::IntVector::operator=(SAMRAI::hier::IntVector *, const SAMRAI::hier::IntVector &)) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h(186,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::IntVector::getNumBlocks(const SAMRAI::hier::IntVector *) const

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::IntVector::getNumBlocks(const SAMRAI::hier::IntVector *) const) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h(215,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::IntVector::operator[](SAMRAI::hier::IntVector *, unsigned int)) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h(253,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::IntVector::operator[](const SAMRAI::hier::IntVector *, unsigned int) const

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::IntVector::operator[](const SAMRAI::hier::IntVector *, unsigned int) const) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h(269,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::IntVector::operator()(const SAMRAI::hier::IntVector *, SAMRAI::hier::BlockId::block_t, unsigned int) const

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::IntVector::operator()(const SAMRAI::hier::IntVector *, SAMRAI::hier::BlockId::block_t, unsigned int) const) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h(340,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::IntVector::operator*=(SAMRAI::hier::IntVector *, int)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::IntVector::operator*=(SAMRAI::hier::IntVector *, int)) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h(555,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::IntVector::operator*(SAMRAI::hier::IntVector *, const SAMRAI::hier::IntVector *, int) const

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::IntVector::operator*(SAMRAI::hier::IntVector *, const SAMRAI::hier::IntVector *, int) const) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h(569,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::IntVector::getZero(const SAMRAI::tbox::Dimension &)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::IntVector::getZero(const SAMRAI::tbox::Dimension &)) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h(1132,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::IntVector::getOne(const SAMRAI::tbox::Dimension &)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::IntVector::getOne(const SAMRAI::tbox::Dimension &)) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/IntVector.h(1145,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::Index::operator+=(SAMRAI::hier::Index *, const SAMRAI::hier::IntVector &)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::Index::operator+=(SAMRAI::hier::Index *, const SAMRAI::hier::IntVector &)) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Index.h(175,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::Index::operator+=(SAMRAI::hier::Index *, int)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::Index::operator+=(SAMRAI::hier::Index *, int)) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Index.h(238,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::Index::operator+(SAMRAI::hier::Index *, const SAMRAI::hier::Index *, int) const

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::Index::operator+(SAMRAI::hier::Index *, const SAMRAI::hier::Index *, int) const) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Index.h(251,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::Index::operator-=(SAMRAI::hier::Index *, const SAMRAI::hier::Index &)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::Index::operator-=(SAMRAI::hier::Index *, const SAMRAI::hier::Index &)) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Index.h(265,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::Index::operator-(SAMRAI::hier::Index *, const SAMRAI::hier::Index *, const SAMRAI::hier::Index &) const

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::Index::operator-(SAMRAI::hier::Index *, const SAMRAI::hier::Index *, const SAMRAI::hier::Index &) const) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Index.h(281,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::Index::operator-=(SAMRAI::hier::Index *, const SAMRAI::hier::IntVector &)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::Index::operator-=(SAMRAI::hier::Index *, const SAMRAI::hier::IntVector &)) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Index.h(297,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::Index::operator()(SAMRAI::hier::Index *, unsigned int)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::Index::operator()(SAMRAI::hier::Index *, unsigned int)) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Index.h(502,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::Index::operator()(const SAMRAI::hier::Index *, unsigned int) const

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::Index::operator()(const SAMRAI::hier::Index *, unsigned int) const) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Index.h(515,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::Index::getDim(const SAMRAI::hier::Index *) const

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::Index::getDim(const SAMRAI::hier::Index *) const) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Index.h(724,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::Box::empty(const SAMRAI::hier::Box *) const

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::Box::empty(const SAMRAI::hier::Box *) const) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Box.h(598,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::Box::getDim(const SAMRAI::hier::Box *) const

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::Box::getDim(const SAMRAI::hier::Box *) const) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Box.h(1298,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::PatchData::getGhostBox(const SAMRAI::hier::PatchData *) const

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::PatchData::getGhostBox(const SAMRAI::hier::PatchData *) const) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/PatchData.h(94,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::PatchData::getGhostCellWidth(const SAMRAI::hier::PatchData *) const

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::PatchData::getGhostCellWidth(const SAMRAI::hier::PatchData *) const) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/PatchData.h(103,4)

===========================================================================

Begin optimization report for: SAMRAI::hier::Patch::getBox(const SAMRAI::hier::Patch *) const

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::hier::Patch::getBox(const SAMRAI::hier::Patch *) const) /home/akula/libraries/SAMRAI/include/SAMRAI/hier/Patch.h(93,4)

===========================================================================

Begin optimization report for: SAMRAI::pdat::CellData<Real>::getDepth(const SAMRAI::pdat::CellData<Real> *) const

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::pdat::CellData<Real>::getDepth(const SAMRAI::pdat::CellData<Real> *) const) /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp(117,1)

===========================================================================

Begin optimization report for: SAMRAI::pdat::CellData<Real>::getPointer(SAMRAI::pdat::CellData<Real> *, int)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::pdat::CellData<Real>::getPointer(SAMRAI::pdat::CellData<Real> *, int)) /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/CellData.cpp(125,1)

===========================================================================

Begin optimization report for: SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::pdat::SideData<Real>::getPointer(SAMRAI::pdat::SideData<Real> *, int, int)) /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/SideData.cpp(157,1)

===========================================================================

Begin optimization report for: SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::pdat::ArrayData<Real>::getPointer(SAMRAI::pdat::ArrayData<Real> *, unsigned int)) /home/akula/libraries/SAMRAI/include/SAMRAI/pdat/ArrayData.cpp(207,1)

===========================================================================

Begin optimization report for: SAMRAI::geom::CartesianPatchGeometry::getDx(const SAMRAI::geom::CartesianPatchGeometry *) const

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (SAMRAI::geom::CartesianPatchGeometry::getDx(const SAMRAI::geom::CartesianPatchGeometry *) const) /home/akula/libraries/SAMRAI/include/SAMRAI/geom/CartesianPatchGeometry.h(70,4)

===========================================================================

Begin optimization report for: __sti__$E()

    Report from: Interprocedural optimizations [ipo]

INLINE REPORT: (__sti__$E()) [552] <compiler generated>
  -> INLINE: /usr/include/c++/4.8.5/iostream:(74,25) __sti___ZN34ConvectiveFluxReconstructorCentral16t_compute_sourceE()
    -> INLINE: /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp:(8,68) std::shared_ptr<SAMRAI::tbox::Timer>::shared_ptr(std::shared_ptr<SAMRAI::tbox::Timer> *)
       {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}
  -> INLINE: /usr/include/c++/4.8.5/iostream:(74,25) __sti___ZN34ConvectiveFluxReconstructorCentral18t_reconstruct_fluxE()
    -> INLINE: /home/akula/HAMeRS_IB/HAMeRS/src/flow/convective_flux_reconstructors/central/ConvectiveFluxReconstructorCentral.cpp:(7,68) std::shared_ptr<SAMRAI::tbox::Timer>::shared_ptr(std::shared_ptr<SAMRAI::tbox::Timer> *)
       {{ Inlining of routines from system headers is omitted. Use -qopt-report=3 to view full report. }}


    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/shared_ptr_base.h(733,17):remark #34000: call to memset implemented inline with stores with proven (alignment, offset): (32, 8)
/usr/include/c++/4.8.5/bits/shared_ptr_base.h(733,17):remark #34000: call to memset implemented inline with stores with proven (alignment, offset): (32, 8)
<compiler generated>:remark #34051: REGISTER ALLOCATION : [__sti__$E] (null):0

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    4[ rdx rbx rsi rdi]
        
    Routine temporaries
        Total         :      23
            Global    :      10
            Local     :      13
        Regenerable   :      17
        Spilled       :       1
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: __sti___ZN34ConvectiveFluxReconstructorCentral18t_reconstruct_fluxE()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (__sti___ZN34ConvectiveFluxReconstructorCentral18t_reconstruct_fluxE()) <compiler generated>

===========================================================================

Begin optimization report for: __sti___ZN34ConvectiveFluxReconstructorCentral16t_compute_sourceE()

    Report from: Interprocedural optimizations [ipo]

DEAD STATIC FUNCTION: (__sti___ZN34ConvectiveFluxReconstructorCentral16t_compute_sourceE()) <compiler generated>

===========================================================================

Begin optimization report for: std::_Hashtable<std::string, std::pair<const std::string, SAMRAI::hier::IntVector>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>, std::__detail::_Select1st, std::equal_to<std::string>, std::hash<std::string>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__umap_traits<true>>::_M_deallocate_node(std::_Hashtable<std::string, std::pair<const std::string, SAMRAI::hier::IntVector>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>, std::__detail::_Select1st, std::equal_to<std::string>, std::hash<std::string>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__umap_traits<true>> *, std::_Hashtable<std::string, std::pair<const std::string, SAMRAI::hier::IntVector>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>, std::__detail::_Select1st, std::equal_to<std::string>, std::hash<std::string>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__umap_traits<true>>::__node_type *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/hashtable.h(745,5):remark #34051: REGISTER ALLOCATION : [_ZNSt10_HashtableISsSt4pairIKSsN6SAMRAI4hier9IntVectorEESaIS5_ENSt8__detail10_Select1stESt8equal_toISsESt4hashISsENS7_18_Mod_range_hashingENS7_20_Default_ranged_hashENS7_20_Prime_rehash_policyENS7_17_Hashtable_traitsILb1ELb0ELb1EEEE18_M_deallocate_nodeEPNS7_10_Hash_nodeIS5_Lb1EEE] /usr/include/c++/4.8.5/bits/hashtable.h:745

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    6[ rax rdx rcx rbx rsi rdi]
        
    Routine temporaries
        Total         :      23
            Global    :      11
            Local     :      12
        Regenerable   :       5
        Spilled       :       1
        
    Routine stack
        Variables     :       1 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================

Begin optimization report for: std::_Hashtable<std::string, std::pair<const std::string, SAMRAI::hier::IntVector>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>, std::__detail::_Select1st, std::equal_to<std::string>, std::hash<std::string>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__umap_traits<true>>::_M_node_allocator(std::_Hashtable<std::string, std::pair<const std::string, SAMRAI::hier::IntVector>, std::allocator<std::pair<const std::string, SAMRAI::hier::IntVector>>, std::__detail::_Select1st, std::equal_to<std::string>, std::hash<std::string>, std::__detail::_Mod_range_hashing, std::__detail::_Default_ranged_hash, std::__detail::_Prime_rehash_policy, std::__umap_traits<true>> *)

    Report from: Code generation optimizations [cg]

/usr/include/c++/4.8.5/bits/hashtable.h(331,7):remark #34051: REGISTER ALLOCATION : [_ZNSt10_HashtableISsSt4pairIKSsN6SAMRAI4hier9IntVectorEESaIS5_ENSt8__detail10_Select1stESt8equal_toISsESt4hashISsENS7_18_Mod_range_hashingENS7_20_Default_ranged_hashENS7_20_Prime_rehash_policyENS7_17_Hashtable_traitsILb1ELb0ELb1EEEE17_M_node_allocatorEv] /usr/include/c++/4.8.5/bits/hashtable.h:331

    Hardware registers
        Reserved     :    2[ rsp rip]
        Available    :   39[ rax rdx rcx rbx rbp rsi rdi r8-r15 mm0-mm7 zmm0-zmm15]
        Callee-save  :    6[ rbx rbp r12-r15]
        Assigned     :    2[ rax rdi]
        
    Routine temporaries
        Total         :      10
            Global    :       0
            Local     :      10
        Regenerable   :       0
        Spilled       :       0
        
    Routine stack
        Variables     :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
        Spills        :       0 bytes*
            Reads     :       0 [0.00e+00 ~ 0.0%]
            Writes    :       0 [0.00e+00 ~ 0.0%]
    
    Notes
    
        *Non-overlapping variables and spills may share stack space,
         so the total stack size might be less than this.
    

===========================================================================
