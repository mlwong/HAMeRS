// Headers for application-specific algorithm/data structure object

#include "HAMeRS_memory.hpp"

#include "algs/integrator/ExtendedTagAndInitialize.hpp"
#include "algs/integrator/RungeKuttaLevelIntegrator.hpp"
#include "apps/Euler/Euler.hpp"
#include "apps/Navier-Stokes/NavierStokes.hpp"
#include "extn/visit_data_writer/ExtendedVisItDataWriter.hpp"

// Headers for basic SAMRAI objects

#include "SAMRAI/SAMRAI_config.h"

#include "SAMRAI/hier/BoxContainer.h"
#include "SAMRAI/hier/Index.h"
#include "SAMRAI/hier/PatchLevel.h"
#include "SAMRAI/hier/VariableDatabase.h"
#include "SAMRAI/tbox/BalancedDepthFirstTree.h"
#include "SAMRAI/tbox/Database.h"
#include "SAMRAI/tbox/InputDatabase.h"
#include "SAMRAI/tbox/InputManager.h"
#include "SAMRAI/tbox/PIO.h"
#include "SAMRAI/tbox/RestartManager.h"
#include "SAMRAI/tbox/SAMRAI_MPI.h"
#include "SAMRAI/tbox/SAMRAIManager.h"
#include "SAMRAI/tbox/SiloDatabaseFactory.h"
#include "SAMRAI/tbox/Timer.h"
#include "SAMRAI/tbox/TimerManager.h"
#include "SAMRAI/tbox/Utilities.h"

// Headers for major algorithm/data structure objects

#include "SAMRAI/algs/TimeRefinementIntegrator.h"
#include "SAMRAI/algs/TimeRefinementLevelStrategy.h"
// #include "SAMRAI/appu/VisItDataWriter.h"
#include "SAMRAI/geom/CartesianGridGeometry.h"
#include "SAMRAI/hier/PatchHierarchy.h"
#include "SAMRAI/mesh/BergerRigoutsos.h"
#include "SAMRAI/mesh/TileClustering.h"
#include "SAMRAI/mesh/GriddingAlgorithm.h"
#include "SAMRAI/mesh/ChopAndPackLoadBalancer.h"
#include "SAMRAI/mesh/TreeLoadBalancer.h"
#include "SAMRAI/mesh/CascadePartitioner.h"

#include <cmath>
#include <dirent.h>
#include <fstream>
#include <stdio.h>
#include <stdlib.h>
#include <string>

#ifndef _MSC_VER
#include <unistd.h>
#endif

#include <sys/stat.h>

#ifdef _OPENMP
#include <omp.h>
#endif

using namespace SAMRAI;

/*
 ************************************************************************
 *
 * This is the main program for an AMR gas dynamics application
 * built using SAMRAI.  The application program is constructed by
 * composing a variety of algorithm objects found in SAMRAI plus some
 * others that are specific to this application.   The following brief
 * discussion summarizes these objects.
 *
 *    hier::PatchHierarchy - A container for the AMR patch hierarchy and
 *       the data on the grid.
 *
 *    geom::CartesianGridGeometry - Defines and maintains the Cartesian
 *       coordinate system on the grid.  The hier::PatchHierarchy
 *       maintains a reference to this object.
 *
 * A single overarching algorithm object drives the time integration
 * and adaptive gridding processes:
 *
 *    algs::TimeRefinementIntegrator - Coordinates time integration and
 *       adaptive gridding procedures for the various levels
 *       in the AMR patch hierarchy.  Local time refinement is
 *       employed during hierarchy integration; i.e., finer
 *       levels are advanced using smaller time increments than
 *       coarser level.  Thus, this object also invokes data
 *       synchronization procedures which couple the solution on
 *       different patch hierarchy levels.
 *
 * The time refinement integrator is not specific to the numerical
 * methods used and the problem being solved.   It maintains references
 * to two other finer grain algorithmic objects, more specific to
 * the problem at hand, with which it is configured when they are
 * passed into its constructor.   They are:
 *
 *    RungeKuttaLevelIntegrator - Defines data management procedures
 *       for level integration, data synchronization between levels,
 *       and tagging cells for refinement.  These operations are
 *       tailored to explicit Runge-Kutta time integration algorithms
 *       used for hyperbolic systems of conservation laws, such as
 *       the Euler equations.  This integrator manages data for
 *       numerical routines that treat individual patches in the AMR
 *       patch hierarchy.  In this particular application, it maintains
 *       a pointer to the Euler object that defines variables and
 *       provides numerical routines for the Euler model.
 *
 *       Euler - Defines variables and numerical routines for the
 *          discrete Euler equations on each patch in the AMR
 *          hierarchy.
 *
 *    mesh::GriddingAlgorithm - Drives the AMR patch hierarchy generation
 *       and regridding procedures.  This object maintains
 *       references to three other algorithmic objects with
 *       which it is configured when they are passed into its
 *       constructor.   They are:
 *
 *       mesh::BergerRigoutsos - Clusters cells tagged for refinement on a
 *          patch level into a collection of logically-rectangular
 *          box domains.
 *
 *       mesh::TreeLoadBalancer - Processes the boxes generated by the
 *          mesh::BergerRigoutsos algorithm into a configuration from
 *          which patches are contructed.  The algorithm we use in this
 *          class assumes a spatially-uniform workload distribution;
 *          thus, it attempts to produce a collection of boxes
 *          each of which contains the same number of cells.  The
 *          load balancer also assigns patches to processors.
 *
 *       ExtendedTagAndInitialize - Couples the gridding algorithm
 *          to the RungeKuttaIntegrator. Selects cells for
 *          refinement based on either Gradient detection, Richardson
 *          extrapolation, or pre-defined Refine box region.  The
 *          object maintains a pointer to the RungeKuttaLevelIntegrator,
 *          which is passed into its constructor, for this purpose.
 *
 ************************************************************************
 */

/*
 *******************************************************************
 *
 * For each run, the input filename and restart information
 * (if needed) must be given on the command line.
 *
 *      For non-restarted case, command line is:
 *
 *          executable <input file name>
 *
 *      For restarted run, command line is:
 *
 *          executable <input file name> <restart directory> \
 *                     <restart number>
 *
 *******************************************************************
 */

enum MODE_LABEL { SIMULATION,
                  POSTPROCESSING };

enum APPLICATION_LABEL { EULER,
                         NAVIER_STOKES };

void runSimulation(
    HAMERS_SHARED_PTR<tbox::InputDatabase> input_db,
    const bool& is_from_restart,
    const std::string& restart_read_dirname,
    const int& restore_num);

void runPostProcessing(
    HAMERS_SHARED_PTR<tbox::InputDatabase> input_db,
    const bool& is_from_restart,
    const std::string& restart_read_dirname,
    const int& restore_num,
    const bool& is_first_restore_index = true,
    const bool& is_ensemble_postprocessing = false,
    const bool& is_first_realization = true,
    const bool& is_last_realization = false,
    const bool& is_last_restore_index = false,
    const int& realizaton_num = 0,
    const int& restore_index = -1);

#include "main_simulation.hpp"
#include "main_postprocessing.hpp"

std::vector<int> getRestoreNumbers(const std::string& restart_read_dirname);

int main(int argc, char *argv[])
{
    /*
     * Initialize tbox::MPI and SAMRAI, enable logging, and process command line.
     */
    
    tbox::SAMRAI_MPI::init(&argc, &argv);
    tbox::SAMRAIManager::initialize();
    tbox::SAMRAIManager::startup();
    
    std::string input_filename;
    std::string restart_read_dirname;
    int restore_num = 0;
    
    bool is_from_restart = false;
    
    if ((argc != 2) && (argc != 3) && (argc != 4))
    {
        tbox::pout << "USAGE:  "
                   << argv[0]
                   << " <input filename> "
                   << "<restart dir> <restore number> [options]\n"
                   << "  options:\n"
                   << "  none at this time"
                   << std::endl;
        tbox::SAMRAI_MPI::abort();
        return -1;
    }
    else
    {
        input_filename = argv[1];
        if (argc == 2)
        {
            is_from_restart = true;
        }
        else if (argc == 3)
        {
            restart_read_dirname = argv[2];
            
            is_from_restart = true;
        }
        else if (argc == 4)
        {
            restart_read_dirname = argv[2];
            restore_num = atoi(argv[3]);
            
            is_from_restart = true;
        }
    }
    
    tbox::plog << "input_filename = " << input_filename << std::endl;
    tbox::plog << "restart_read_dirname = " << restart_read_dirname << std::endl;
    tbox::plog << "restore_num = " << restore_num << std::endl;
    
    /*
     * Create input database and parse all data in input file.
     */
    
    HAMERS_SHARED_PTR<tbox::InputDatabase> input_db(new tbox::InputDatabase("input_db"));
    tbox::InputManager::getManager()->parseInputFile(input_filename, input_db);
    
    /*
     * Retrieve "GlobalInputs" section of the input database and set
     * values accordingly.
     */
    
    if (input_db->keyExists("GlobalInputs"))
    {
        HAMERS_SHARED_PTR<tbox::Database> global_db(input_db->getDatabase("GlobalInputs"));
        
        if (global_db->keyExists("call_abort_in_serial_instead_of_exit"))
        {
            bool flag = global_db->getBool("call_abort_in_serial_instead_of_exit");
            tbox::SAMRAI_MPI::setCallAbortInSerialInsteadOfExit(flag);
        }
    }
    
    MODE_LABEL mode_label = SIMULATION;
    
    std::string mode_string = input_db->getStringWithDefault("Mode", "SIMULATION");
    
    if (mode_string == "SIMULATION")
    {
        mode_label = SIMULATION;
        if (argc == 2)
        {
            is_from_restart = false;
        }
    }
    else if (mode_string == "POSTPROCESSING")
    {
        mode_label = POSTPROCESSING;
    }
    else
    {
        TBOX_ERROR("Unkonwn mode string = '"
             << mode_string
             << "' found in input database."
             << std::endl); 
    }
    
    if (argc == 3 && (mode_label != POSTPROCESSING))
    {
        TBOX_ERROR("Number of arguments is three while not in post-processing mode."
             << std::endl); 
    }
    
    if (mode_label == SIMULATION)
    {
        runSimulation(input_db,
            is_from_restart,
            restart_read_dirname,
            restore_num);
    }
    else if (mode_label == POSTPROCESSING)
    {
        if (argc == 2)
        {
            // Check whether it is ensemble post-processing.
            bool is_ensemble_postprocessing = false;
            
            HAMERS_SHARED_PTR<tbox::Database> postprocess_db;
            if (input_db->keyExists("PostProcessing"))
            {
                postprocess_db = input_db->getDatabase("PostProcessing");
                is_ensemble_postprocessing = postprocess_db->getBoolWithDefault(
                    "is_ensemble_postprocessing",
                    false);;
            }
            else
            {
                TBOX_ERROR("Unknown post-processing settings in post-processing mode when number of arguments is three. "
                    << std::endl
                    << "Please provide the 'PostProcessing' database."
                    << std::endl);
            }
            
            if (!is_ensemble_postprocessing)
            {
                TBOX_ERROR("Number of arguments is two while not in ensemble post-processing mode."
                     << std::endl);
            }
            
            // Get all of the directories for ensemble post-processing.
            
            std::vector<std::string> restart_read_dirnames;
            if (postprocess_db->keyExists("restart_read_dirnames"))
            {
                restart_read_dirnames = postprocess_db->getStringVector("restart_read_dirnames");
            }
            else
            {
                TBOX_ERROR("Key data 'restart_read_dirnames' not found in input."
                    << std::endl);
            }
            
            int restore_index_start = 0;
            if (postprocess_db->keyExists("restore_index_start"))
            {
                restore_index_start = postprocess_db->getInteger("restore_index_start");
                if (restore_index_start < 0)
                {
                    TBOX_ERROR("Key data 'restore_index_start' is smaller than zero."
                        << std::endl);
                }
            }
            else
            {
                TBOX_ERROR("Key data 'restore_index_start' not found in input."
                    << std::endl);
            }
            
            int restore_index_end = 0;
            if (postprocess_db->keyExists("restore_index_end"))
            {
                restore_index_end = postprocess_db->getInteger("restore_index_end");
                if (restore_index_end < 0)
                {
                    TBOX_ERROR("Key data 'restore_index_end' is smaller than zero."
                        << std::endl);
                }
            }
            else
            {
                TBOX_ERROR("Key data 'restore_index_end' not found in input."
                    << std::endl);
            }
            
            if (restore_index_start > restore_index_end)
            {
                TBOX_ERROR("Key data 'restore_index_end' is smaller than key data 'restore_index_start'."
                    << std::endl);
            }
            
            int restore_index_stride = 1;
            if (postprocess_db->keyExists("restore_index_stride"))
            {
                restore_index_stride = postprocess_db->getInteger("restore_index_stride");
                if (restore_index_stride < 1)
                {
                    TBOX_ERROR("Key data 'restore_index_end' is smaller than one."
                        << std::endl);
                }
            }
            
            const int num_ensembles = static_cast<int>(restart_read_dirnames.size());
            
            for (int i = restore_index_start; i <= restore_index_end; i += restore_index_stride)
            {
                const bool is_first_restore_index = (i == restore_index_start);
                const bool is_last_restore_index  = (i == restore_index_end - 1);
                
                for (int ri = 0; ri < num_ensembles; ri++)
                {
                    const std::string restart_read_dirname = restart_read_dirnames[ri];
                    std::vector<int> restore_nums = getRestoreNumbers(restart_read_dirname);
                    
                    if (restore_index_start >= static_cast<int>(restore_nums.size()))
                    {
                        TBOX_ERROR("Key data 'restore_index_start' is larger than available indices of realization #"
                            << ri << "."
                            << std::endl);
                    }
                    
                    if (restore_index_end >= static_cast<int>(restore_nums.size()))
                    {
                        TBOX_ERROR("Key data 'restore_index_end' is larger than available indices of realization #"
                            << ri << "."
                            << std::endl);
                    }
                    
                    const int& restore_num = restore_nums[i];
                    
                    const bool is_first_realization = (ri == 0);
                    const bool is_last_realization  = (ri == num_ensembles - 1);
                    
                    runPostProcessing(
                        input_db,
                        is_from_restart,
                        restart_read_dirname,
                        restore_num,
                        is_first_restore_index,
                        is_ensemble_postprocessing,
                        is_first_realization,
                        is_last_realization,
                        is_last_restore_index,
                        ri,
                        i);
                    
                    tbox::SAMRAIManager::shutdown();
                    tbox::SAMRAIManager::startup();
                }
            }
        }
        else if (argc == 3)
        {
            std::vector<int> restore_nums = getRestoreNumbers(restart_read_dirname);
            
            HAMERS_SHARED_PTR<tbox::Database> postprocess_db;
            if (input_db->keyExists("PostProcessing"))
            {
                postprocess_db = input_db->getDatabase("PostProcessing");
            }
            else
            {
                TBOX_ERROR("Unknown post-processing settings in post-processing mode when number of arguments is three. "
                    << std::endl
                    << "Please provide the 'PostProcessing' database."
                    << std::endl);
            }
            
            int restore_index_start = 0;
            if (postprocess_db->keyExists("restore_index_start"))
            {
                restore_index_start = postprocess_db->getInteger("restore_index_start");
                if (restore_index_start < 0)
                {
                    TBOX_ERROR("Key data 'restore_index_start' is smaller than zero."
                        << std::endl);
                }
                if (restore_index_start >= static_cast<int>(restore_nums.size()))
                {
                    TBOX_ERROR("Key data 'restore_index_start' is larger than available indices."
                        << std::endl);
                }
            }
            else
            {
                TBOX_ERROR("Key data 'restore_index_start' not found in input."
                    << std::endl);
            }
            
            int restore_index_end = 0;
            if (postprocess_db->keyExists("restore_index_end"))
            {
                restore_index_end = postprocess_db->getInteger("restore_index_end");
                if (restore_index_end < 0)
                {
                    TBOX_ERROR("Key data 'restore_index_end' is smaller than zero."
                        << std::endl);
                }
                if (restore_index_end >= static_cast<int>(restore_nums.size()))
                {
                    TBOX_ERROR("Key data 'restore_index_end' is larger than available indices."
                        << std::endl);
                }
            }
            else
            {
                TBOX_ERROR("Key data 'restore_index_end' not found in input."
                    << std::endl);
            }
            
            if (restore_index_start > restore_index_end)
            {
                TBOX_ERROR("Key data 'restore_index_end' is smaller than key data 'restore_index_start'."
                    << std::endl);
            }
            
            int restore_index_stride = 1;
            if (postprocess_db->keyExists("restore_index_stride"))
            {
                restore_index_stride = postprocess_db->getInteger("restore_index_stride");
                if (restore_index_stride < 1)
                {
                    TBOX_ERROR("Key data 'restore_index_end' is smaller than one."
                        << std::endl);
                }
            }
            
            for (int i = restore_index_start; i <= restore_index_end; i += restore_index_stride)
            {
                const int& restore_num = restore_nums[i];
                const bool is_first_restore_index = (i == restore_index_start);
                
                runPostProcessing(
                    input_db,
                    is_from_restart,
                    restart_read_dirname,
                    restore_num,
                    is_first_restore_index);
            
                tbox::SAMRAIManager::shutdown();
                tbox::SAMRAIManager::startup();
            }
        }
        else
        {
            runPostProcessing(
                input_db,
                is_from_restart,
                restart_read_dirname,
                restore_num);
        }
    }
    
    tbox::SAMRAIManager::shutdown();
    tbox::SAMRAIManager::finalize();
    tbox::SAMRAI_MPI::finalize();
   
    return 0;
}


std::vector<int>
getRestoreNumbers(const std::string& restart_read_dirname)
{
    std::vector<int> restore_nums;
    DIR *dir; struct dirent *diread;
    std::string prefix = "restore.";
    
    if ((dir = opendir(restart_read_dirname.c_str())) != nullptr)
    {
        while ((diread = readdir(dir)) != nullptr)
        {
            std::string dummy = diread->d_name;
            if ((dummy != ".." && dummy != ".") && (dummy.find(prefix) != std::string::npos))
            {
                size_t pos = dummy.find(prefix);
                dummy.erase(pos, prefix.length());
                
                restore_nums.push_back(atoi(dummy.c_str()));
            }
        }
        closedir(dir);
    }
    else
    {
        TBOX_ERROR("Unknown error in getting restore numbers with restart_read_dirname = '"
            << restart_read_dirname << "'."
            << std::endl);
    }
    
    std::sort(restore_nums.begin(), restore_nums.end());
    
    // for (const int& restore_num : restore_nums)
    // {
    //     std::cout << restore_num << " | ";
    // }
    // std::cout << std::endl;
    
    return restore_nums;
}
